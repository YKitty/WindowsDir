# 三次握手四次挥手

-----

插图：三次握手四次挥手

![](C:\Users\0\Pictures\Linux网络\TCP\三次握手.jpg)



## 三次握手

> 三次握手是TCP建立连接时的机制



### 三次握手的过程

TCP建立连接的时候会发送三个数据报进行确认。

三次握手的目的是连接到服务器指定端口，建立TCP连接，并同步双方序列号和确认号以及交换窗口大小信息。

在socket编程中，客户端执行connect()时，将触发三次握手

- 第一次握手：客户端将SYN标志位置1，随机产生一个序列号x，将数据包发送给服务器，此时客户端进行SYN_SENT状态
- 第二次握手：服务器收到客户端的数据报查看SYN标志位为1知道客户段要建立连接，服务器将SYN标志位以及ACK标志位置1，并且ack（确认序号）设为x + 1，随机产生一个自己序列号值y，将该数据包发送给客户端。用来确定客户端的连接，同时进行序号的同步。服务器进入SYN_RECV状态
- 第三次握手：客户端收到服务器的应答以及请求。然后发送应答，确认序号为y + 1，将这个数据包发送给服务器端，然后客户端进入到ESTABLISHED状态，如果服务器收到客户端的确认应答也就进入到ESTABLISHED状态，建立连接成功



## 四次挥手

在socket编程中，有客户端或者服务器任意端执行close()时，将触发四次挥手

- 客户端发送一个FIN数据包，用来关闭客户端到服务器端的数据传输，客户端进入到FIN_WAIT_1状态
- 服务器收到FIN数据包后，发送一个ACK给客户端，确认序号为收到序号加一（与SYN一样，一直FIN占用一个序号），服务器端进入到CLOSE_WAIT状态，
- 客户端收到服务器端的确认应答，此时客户端进入到FIN_WAIT_2状态
- 服务器将自己要发送的数据发送完毕，服务器发送一个FIN数据包，用来关闭服务器到客户端的数据传输，服务器进入到LAST_ACK状态
- 客户端接收到服务器的FIN数据包后，客户端进入到TIME_WAIT状态，接着发送一个ACK给服务器，此时客户端还没有进入到CLOSED状态，必须的等待2MSL的时间后，客户端才进入CLOSED状态
- 服务器收到客户端的确认应答之后进入CLOSED状态



## 各种问题：

### 为什么不是一次握手呢？

- 如果是一次握手的话，就不会产生确认应答机制，就无法同步客户端和服务器的状态，有可能发送的数据都是错的。还有就是客户端认为连接成功了，但是其实没有连接成功，就会一直超时重发



### 为什么不是两次握手呢？

- 如果服务器给客户端的应答的数据报丢失了，服务器就会认为连接成功，但是客户端没有收到应答报文就会认为没有连接成功，就会再次发送SYN请求连接报文，就会大量浪费服务器的资源
- 如果客户端给服务器发送的SYN报文，由于网络的原因延迟了。由于服务没有接受到客户端发送的SYN报文，客户端就会发送在发送一个SYN报文，建立连接，发送数据，数据发送完毕，释放连接。这时延迟的SYN报文来到了，服务就会认为这是一个新的报文，服务器就会发送一个ACK（确认应答）和客户端建立连接，此时就出错了



### 为什么不是四次握手呢？

- 四次握手的话，就有可能出现服务器最后一次的ACK丢失，但是服务器已经认为建立连接了，但是客户端没有收到ACK报文就会一直给服务器发送报文，导致浪费服务器的资源

1. 客户端给服务器发送FIN报文
2. 服务器给客户端发送ACK应答报文
3. 服务器给客户端发送FIN报文
4. 客户端给服务器发送ACK应答报文

- 对于四次握手也就是第二步和第三步之间没有数据的发送，客户端和服务器端只是进行建立连接而已，服务器发送ACK（确认应答）给客户端之后，然后再给客户端发送一个FIN报文，分开发送相当于多发了一次TCP报文段，但是对于FIN和ACK这两个是TCP报文首部的两个标识，可以一次发送，所以将其进行合并之后，从而提高连接的速度和效率



### 为什么四次挥手呢？

- 因为TCP协议是全双工的，每个方向都要进行单独的关闭连接。这就说明当一方的数据发送完毕之后就会向对端发送FIN报文来终止这一方向上的连接**（不可在发送数据，还可以接收数据）处于半关闭状态**。但是**对端仍可以发送数据，直到对端也将数据发完，发送FIN报文。从而断开连接。**



### 半连接

在三次握手中，服务器发送完FIN+ACK之后，收到客户端的ACK之前TCP连接处于半连接



### 半关闭

在四次挥手中，有一方不在进行数据传输，而另一方仍可以进行数据传输，此时TCP连接处于半关闭



### SYN攻击

- 客户端在短时间内伪造大量不存在的IP地址，并向服务器发送连接请求，服务器确认应答之后等待客户端的应答，但是由于等不到，服务器端就会不断的超时重发，并且这些伪造的IP地址一直占用着服务器端的连接队列，导致正常的SYN请求由于队列已满不能建立连接，从而引起网络堵塞。

**防范措施：** 
　　1、降低SYN timeout时间，使得主机尽快释放半连接的占用 
　　2、采用SYN cookie设置，如果短时间内连续收到某个IP的重复SYN请求，则认为受到了该IP的攻击，丢弃来自该IP的后续请求报文 

　　3、在网关处设置过滤，拒绝将一个源IP地址**不属于其来源子网（不属于这个源IP地址）**的包进行更远的路由 （也就是可以将一个源IP地址不属于来源子网的包进行更远的路由）





### 为什么是建立连接时三次握手，而断开连接时四次挥手呢？

- 这是因为在建立连接的时候，服务器收到客户端的SYN报文连接请求之后，服务器可以将ACK和FIN放在一个报文中发送。但关闭连接的时候，服务器收到客户端到FIN报文的之后，只是表明客户端没有数据发送给你了，但未必你所有的数据都发给对方，所以未必是立马关闭socket，有可能将数据发送完毕之后，在发送FIN报文给对方表示可以关闭连接了。
- 建立连接的时候，因为没有数据的传输，所以FIN和ACK可以放到一个包中，进行传输
- 但是对于释放连接的时候，一端收到FIN之后，但此时仍有数据没有处理完，所以此时就只能先向对端应答一个ACK报文段，然后再发送自己未发送完的数据，等到将自己要发送的数据发送完了之后，再向对端发送FIN报文断开这个方向的连接
- 因此很多时候FIN和ACK都需要在两个数据报中进行发送，因此需要四次挥手



### 三次握手建立连接时，发送方再次发送确认的必要性？

- 主要是为了防止已失效的连接请求报文段突然又传到了B,因而产生错误。假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络结 点长时间滞留了，一直延迟到连接释放以后的某个时间才到达B，本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次 新的连接请求，于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了，这样一直等待A发来数据，B的许多 资源就这样白白浪费了。




### 特殊状态：CLOSING状态

正常情况下是一方发送FIN报文之后，应该先收到对方的ACK报文然后在收到对方的FIN报文。但是CLOSING状态表示一方发送FIN报文之后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。

这是什么情况下会出现这种情况呢？

那就是当几乎通水关闭close()一个socket的话，就出现双方同时发送FIN报文情况，这是就会出现CLOSING状态，表示双方都在关闭socket连接



### 如果已经建立了连接，但是客户端突然出现故障了怎么办？

- TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。



### 死亡值ping

许多操作系统的TCP/IP协议栈规定ICMP包大小为64KB，且在对包的标题头进行读取之后，要根据该标题头里包含的信息来为有效载荷生成缓冲区。”死亡值ping”就是故意产生畸形的测试ping包，声称自己的尺寸超过ICMP上限，也就是加载的尺寸超过64KB上限，使未采取保护措施的网络系统出现内存分配错误，导致TCP/IP协议栈崩溃，最终接收方宕机。 



### 超时重传和快重传的区别

- 超时重传：当发送端发送一个数据报之后，没有在超时重传的时间内收到确认应答，就会超时重传
- 快重传：当发送端，发送序号分别为1,1001,2001,3001,4001,5001的数据报之后，接收端收到了序号为1,2001,3001,4001，5001的数据报，没有收到序号为1001的数据报，接收端就会一直刚给发送端发送确认应答为1001的序号的数据报，请求客户端将这个数据报发送过来，当接收端收到连续的三个重复的确认应答就会立刻重发这个数据报，而不会等到超时的时间



### accept发生在三次握手中的那一位置

- accept会检测已完成队列是否为空，当队列为空，accept就会阻塞，当队列非空的时候，就从已完成的队列中取出一项并返回
- 而已完成队列都是三次握手过程已经结束的了，所以accept会发生在三次握手结束之后



### 客户端的状态迁移

**`CLOSED->SYN_SENT->ESTABLISHED->FIN_WAUT_1->FIN_WAIT_2->TIME_WAIT->CLOSED`**



### 服务器的状态迁移

**`CLOSED->LISTEN->SYN_RCVD->ESTABLISHED->CLOSE_WIAT->LASK_ACK->CLOSED`**



对于TCP连接中某些状态解析：

CLOSED：初识状态，表示TCP连接时“关闭着的”或“未打开的”

LISTEN：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接

FIN_WAIT_2 ：实际上FIN_WAIT_2状态下的SOCKET表示半连接，即有一方调用close()主动要求关闭连接。注意：FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态），这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个 FIN_WAIT_2 状态将一直保持到系统重启，越来越多的FIN_WAIT_2 状态会导致内核crash。

CLOSE_WAIT ：表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己，你的系统毫无疑问地将会回应一个ACK报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。

