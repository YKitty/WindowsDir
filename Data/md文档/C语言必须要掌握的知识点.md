# C语言必须要掌握的知识点

----

## 1. 结构体的内存对齐

### 1.1 如何对齐的

> 1. 第一个成员在结构体变量偏移量为0的地址处
> 2. 其他成员变量要对齐到对齐数的整数倍的地址处。
>    - 对齐数 = Min（编译器默认对齐数， 该成员变量大小）
>    - VS默认是8，Linux的默认值是4
> 3. 结构体总大小为最大对齐数的整数倍
> 4. 如果嵌套了结构体的情况，嵌套结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是最大对齐数（含嵌套结构体的对齐数）的整数倍



### 1.2 为什么要对齐呢？

> - **平台原因（移植原因）：**
>   - **不是所有的硬件平台都能访问任意地址上的任意数据的**；某些硬件平台只能访问某些地址处某些特定的类型，否则抛出硬件异常
> - **性能原因：**
>   - 数据结构（尤其是栈）应该尽可能地在自然边界上对齐
>   - 原因在于，**为了访问未对齐的内存，处理器需要做两次访问；而对其的那内存访问仅需要一次访问**



### 1.3 结构体传参

>  对于结构体传参要**传结构体的地址**，如果穿结构体的话压栈的开销较大，性能就会下降



### 1.4 总结

> 内存对齐是拿空间换取时间的做法



## 2. 位段

### 2.1 概念

> 位段就是对于一个可以自己定义一个int类型的变量，然后自己定义该变量可以占多少位，也就是对于一个int类型的变量可以不需要必须是4字节，可以是一位，两位等等



### 2.2 声明

> - 位段的成员必须是**`int、unsigned int、signed int`**
> - 位段的**成员名后面有一个冒号和一个数字**
>
> 比如：
>
> ``` c++
> struct A
> {
>     int _a:2;
>     int _b:5;
>     int _c:10;
>     int _d:30;
> };
> ```
>
> A就是一个位段类型，那么A位段的大小是多少呢？
>
> - 2个字节，由于 _a, _b, _c三个变量扎了一个字节， _d独自占了一个字节



### 2.3 位段的内存分配

> 1. 位段的成员可以是**`int，unsigned int，signed int，char`**（属于整形家族）
> 2. 位段空间上是需要按照4个字节（int）或者1个字节（char）的大小来开辟的
> 3. 位段不可跨平台，对于可移植程序应该避免使用位段
>
> 比如：
>
> ``` c++
> struct S
> {
>     char a : 3;
>     char b : 4;
>     char c : 5;
>     char d : 4;
> };
> 
> struct S s = { 0 };
>     s.a = 2;
>     s.b = 5;
>     s.c = 3;
>     s.d = 4;
> //空间是如何开辟的
> ```
>
> 经过在VS2017下测试：
>
> 是这样开辟空间的，对于a是一个字符变量也就是，有8位a只用了3位，还剩下5位，但是b只需要4位，这时候b就用了a剩下的5位，到c的时候不够了，就有开辟了一个字节的空间，剩下3位对于d不够用，就又开辟了一个字节的空间。
>
> a用的时候，是从右边开始使用的，也就是使用的是一个字节中的低位字节序，而高位字节序是给b使用了。
>
> 所以对于a，b所占用的字节，开始
>
> a用：2   （00000010）：2
>
> b用：2a （00101010）：2a（42）



### 2.4 位段的跨平台问题

> 1. int位段被当做有符号数还是无符号数不确定
> 2. 位段中最大位的数目不能确定对于一个int类型的数据，16位机下是16，,3位机是32位，写成27的话，在16位机下就会出错
> 3. 位段中的成员在内存中从左向右分配还是从右向左分配没有标准**（VS2017，从右向左分配）**
> 4. 当一个结构中包含两个位段，第二个位段成员比较大，无法容纳与第一个位段剩余的位时，是舍弃剩余的位还是利用不确定。**（VS2017，舍弃）**



### 2.5 总结

> 跟结构体相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题（移植性不高）



## 3. 联合体

### 3.1 大小的计算

> - 联合体的大小至少是最大成员的大小
> - 当最大成员的大小不是最大对齐数的整数倍的时候，就要对其到最大对齐数的整数倍



### 3.2 联合和结构体求点分十进制

> ``` c++
> int main()
> {
> 	union ip_addr
> 	{
> 		unsigned long addr;
> 		struct
> 		{
>             //必须使用无符号类型的，否则有可能出现负数
> 			unsigned char c1;
> 			unsigned char c2;
> 			unsigned char c3;
> 			unsigned char c4;
> 		}ip;
> 	};
> 	union ip_addr my_ip;
> 	my_ip.addr = 176238749;
> 	printf("%d.%d.%d.%d\n", my_ip.ip.c4, my_ip.ip.c3, my_ip.ip.c2, my_ip.ip.c1);//小端的输出方法
>     
> 	return 0;
> }
> ```
>
> 



