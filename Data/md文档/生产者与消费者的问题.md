# 生产者与消费者的问题

----

## #基于阻塞队列的生产者和消费者

## 1. 生产者与消费者通知的时序问题

> **【对于生产者】**
>
> - 当生产者先等待后通知的话，就会导致消费者无法消费
> - 当生产者先通知后等待的话，消费者就可以正常消费
>
> **【对于消费者】**
>
> - 当消费者先等待后通知的话，就会导致生产者无法生产
> - 当消费者先通知后等待的话，生产者就可以正常生产
>
> **【总结】：**
>
> - **必须先通知然后自己在等待**



## 2. 对于如果先创建消费者

> - 对于先创建消费者，生产者是每次0.2s生产一个
> - 为什么会导致有时生产者生产一个数据，就被消费者消费了
>
> **【原因】**
>
> - 这是由于刚开始的时候生产者和消费者都是同时开始运行的，同时竞争锁的资源，如果出现，生产者生产一个数据，消费者就消费一个数据，这是因为
> - 对于生产者先竞争到锁，生产了一个数据，然后消费者就在锁的外面等着，立马就拿到锁资源，然后消费了这个数据，消费者出来，这就有可能导致了生产者生产了一个数据，消费者消费一个数据。
> - 如果要想可以就是生产者生产一批数据，消费者消费一批数据，
> - 就必须要生产者一下子连续生产将数据生产满，然后生产者进行条件等待（此时已经将锁资源进行释放了），等到消费者把数据消费完了之后，给生产者发送唤醒条件，使生产者继续生产。
> - 或者消费者一下子把数据消费完了，然后陷入条件等待，使生产者改变条件给消费者发送唤醒信号。



## 3. 对于等待条件变量的线程为什么要用while去判断条件呢？

> - 这是因为有可能造成**虚假唤醒**的问题
>
> **【虚假唤醒】：**
>
> **【定义】**
>
> - 在多核处理器下，pthread_cond_signal有可能激活多个线程（在该条件变量下的线程）,结果就是当一个线程执行pthread_cond_signal函数，有可能有多个调用pthread_cond_wait的线程返回，这就是“虚假唤醒”。
>
> **【例子】**
>
> - 对于有三个线程和一个消费者队列
> - 1号线程从队列中获得一个数据，此时队列变为空
> - 2号线程此时也想从队列中获得一个数据，但是此时队列为空了，所以2号线程就会进入条件等待，等待队列非空
> - 此时3号线程给队列增加了一个元素，并调用signal函数通知2号线程，让其去读取数据
> - 处于等待中的2号线程接收到3号线程的信号，就准备去解除阻塞状态，然后获取锁资源随后去读取数据
> - 但是有可能此时1号线程刚刚执行完之前的元素操作，返回再去读取队列中的元素，1号线程获取队列的锁，然后再判断队列非空，读取队列的元素然后释放队列的锁
> - 等到2号线程获得队列的锁，判断发现队列为空，1号线程“偷走”了这个数据，所以对于2号线程来说这次唤醒就是“虚假的”，他需要再次等待队列变为非空
>
>  
>
> 如果用if判断，多个等待线程在满足if条件时都会被唤醒(虚假的)，但实际上条件并不满足，生产者生产出来的消费品已经被第一个线程消费了。 
>
> 这就是我们使用while去做判断而不是使用if的原因：因为等待在条件变量上的线程被唤醒有可能不是因为条件满足而是由于虚假唤醒。所以，我们需要对条件变量的状态进行不断检查直到其满足条件，不仅要在pthread_cond_wait前检查条件是否成立，在pthread_cond_wait之后也要检查。
>
> 参考的博客：https://blog.csdn.net/Leeds1993/article/details/52738845 



## #基于信号量的生产者与消费者

## 1. 信号量是如何实现同步和互斥的

> - 其实在对于两个信号量进行初始化的时候，就已经实现了同步和互斥
> - 对于block信号量，刚开始设置为数组大小
> - 对于data信号量，开始设置为0
>
> **【Push操作】**
>
> - block信号量`--`，data信号量`++`
>
> **【Pop操作】**
>
> - block信号量`++`，data信号量`--`



## #线程池

## 1. 线程调用函数为static函数的原因

> - 类内线程执行的函数必须使用static，因为该函数只能有一个参数arg，如果不用static修饰的话，函数会有一个隐含的this指针。（就会出错）







