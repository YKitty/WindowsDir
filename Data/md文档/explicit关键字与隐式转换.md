# explicit关键字与隐式转换

> **只有一个参数的构造函数也定义了一个隐式转换，将该构造函数的参数的类型的数据转化为一个该类的对象**
>
> 对于**explicit关键字**只可以用于**修饰构造函数或者转换函数**
>
> **对于构造函数，如果添加了explicit关键字表示，该构造函数不可进行隐式转换**
>
> 说道这里，怕就有人会问**隐式转换**是什么东西呢？
>
> 话不多说，先看一段代码？
>
> ``` c++
> class mystring 
>   {
>   public:
>     //给空字符串是为了，对于一个未初始化的对象，它的size(大小)应该是0，而不应该不存在
>     //没有加explicit关键字也就是可以进行隐式转换
>     mystring(const char* str = "")
>       : _str(new char[strlen(str) + 1])
>       , _size(0)
>       , _capacity(0)
>       {
>         strcpy(_str, str);
>       }
>     
>     const mystring& operator=(const mystring& str)
>     {
>       //不是自己给自己赋值
>       if (this != &str)
>       {
>         delete[] _str;
>         _str = new char[strlen(str._str) + 1];
>         strcpy(_str, str._str);
>       }
> 
>       return *this;
>     }
>     
>   private:
>     char* _str;//字符串数组
>     int _size;//大小
>     int _capacity;//容量
>   };
> ```
>
> - 这是一个类，该类中只是**重载了=**的一种形式，也就是**参数为mystring& str**这个**引用**
>
> 下面再看这样调用这个类的主函数
>
> ``` c++
> #include <iostream>
> #include "mystring.h"
> 
> int main()
> {
>   MyString::mystring str("hello world");
>   //对于"hello"这是一个operator=的重载,对于该函数调用operator之后，发现其形参是mystring& str就会到调用构造函数的隐式转换，
>   //将"hello "进行隐式转换，将其转化为一个mystring& tmp对象，然后用该对象对当前对象进行赋值操作
>   //解决办法：将构造函数的隐式转换开着就行了，也就是不需要增加explicit关键字
>   str = "hello";
>   std::cout << str << '\n';
>   return 0;
> }
> ```
>
> - 这一个主函数里面，定义了一个str对象，然后对这个对象进行了**` str = "hello" `**这一条语句，但是我们只是重载了参数是mystring& str引用的一个函数，为什么这个可以执行过去呢？
> - 其实在这里就是进行了**隐式转换**
>   - 隐式转换就是对于这个字符串，将其**调用构造函数**，**临时创建了**一个**mystring& tmp的对象**，然后用这个**tmp对象**去对当前对象**进行赋值操作**。这样就可以调用我们写的这个赋值运算的重载函数了。最重要的就是这个**字符串变成**了一个**临时对象**，这就是隐式转换。**（就是我们看不到的时候，他自己偷偷地变了一个类型）**
>   - **隐式转换就是调用了构造函数**
>   - 如果我们不想让操作系统自己偷偷的进行这个操作的话，其实创建c++的人已经想到了这一点了，给我们提供了一个**关键字（explicit）**，这个关键字就可以让**操作系统不再偷偷地背着我们做坏事**。
>   - 只需要将这个**关键字增加到构造函数的开头**，这样的话，这个**赋值运算符的重载的函数**就**不会再进行隐式转换**了，从而出错，大家可以运行一下代码，测试一下。
>
> **这是进行了隐式转换之后是正确的，但是我们有的时候不需要进行隐式转化，如下：**
>
> ``` c++
> class String
> {
>     String(int n);//本意是预先分配n个字节给字符串
>     String(const char* p);//用C风格的字符串p作为初始值
> }
> ```
>
> 下面两种写法正确（**写法一）**：
>
> ``` c++
> String s2(10);//分配10个字节的空字符串
> String s3 = String(10);
> ```
>
> 但是对于下面两种写法就比较疑惑了**（写法二）**:
>
> ``` c++
> String s4 = 10;//编译通过，分配10个字节的空字符串
> String s5 = 'a';//编译通过，分配int('a')个字节的空字符串
> ```
>
> **s4和s5分别把一个int型和char型，隐式转换成了分配若干字节的空字符串，容易令人误解。为了避免这种错误的发生，我们可以声明显示的转换，使用explicit关键字**
>
> ``` c++
> class String
> {
>     explicit String(int n);//本意是预先分配n个字节给字符串
>     String(const char* p);//用C风格的字符串p作为初始值
> }
> ```
>
> **加上explicit关键字，就抑制了String(int n)的隐式转换了**
>
> 对于写法一仍然还是正确的，对于写法二就会报错，所以对于某些时候，**explicit关键字可以有效地防止构造函数的隐式转换带来的错误或者误解**



