# HTTP协议

----

## # 前言

> **HTTP（超文本传输协议）协议是处于应用层的协议**
>
> - **应用层协议**
>   - **协议**其实就**是**一种**约定**
>   - **应用层协议是程序员自己写的**



## # URL的认识

> - **URL就是网址**
> - 插图：URL详解
>
> **【注意】**
>
> - **?前面**的是要**访问的资源**
> - **?后面**的是**传递给服务器的相关参数**
> - **URL有目录**表示**服务器使用Linux实现**:该目录是Web服务器的目录，一般不是根目录
> - **片段标识符**：网页中内嵌的元素，有可能是第几个
>
>  
>
> **urlencode和urldecode**
>
> 对于像**/ ? :**这样的字符已经被**url当做特殊意义的字符**进行处理了，所以这些字符不能轻易的出现。
>
> 但是对于有的**参数中必须有这样的字符**的时候，就必须对这些字符**进行转义**
>
> - **转义的规则**
>   - 将需要进行转码的字符**转为16进制**，然后**从右到左**，**取4位（不足四位直接处理）**，**每2位做一位，前面加上%**，编码成**%XY的形式**
>   - 例如：在百度搜索C++的时候，**"+"就会被转义为"%2B"**
>   - **urldecode即使urlencode的逆过程**
> - **其实这也即使一个序列化和反序列化的过程**



## # HTTP协议的格式

> **对于HTTP的请求和响应一般分为三到四部分**
>
> - **HTTP请求**
>   - **请求行**
>     - 方法+url+版本
>   - **请求报头**
>     - 以行为单位的
>     - 使用key：value来表示。key代表属性，value代表信息
>   - **空行**
>     - 将报头和有效载荷进行分离
>   - **请求正文**
>     - 一般是用户名和密码
>     - 请求报文可以是空字符串，但是如果存在的话，那么在报头中就要有着一个Content-Length属性来标识请求报文的长度
> - **HTTP响应**
>   - **状态行**
>     - 版本号+状态码+状态码解释
>   - **响应报头**
>     - 以行为单位
>     - 使用key：value来表示。key代表属性，value代表信息
>   - **空行**
>     - 将报头和有效载荷进行分离
>   - **响应正文**
>     - 响应正文可以是空字符串，但是如果存在的话，那么在报头中就会有着一个Content-Length属性来标识响应正文的长度



## # HTTP的方法

> |  方法   |          说明          | 支持的HTTP协议版本 |
> | :-----: | :--------------------: | :----------------: |
> |   GET   |        获取资源        |      1.0、1.1      |
> |  POST   |      传输实体主体      |      1.0、1.1      |
> |   PUT   |        传输文件        |      1.0、1.1      |
> |  HEAD   |      获得报文首部      |      1.0、1.1      |
> | DELETE  |        删除文件        |      1.0、1.1      |
> | OPTIONS |     询问支持的方法     |        1.1         |
> |  TRACE  |        追踪路径        |        1.1         |
> | CONNECT | 要求用隧道协议连接代理 |        1.1         |
> |  LINK   |  建立和资源之间的关系  |        1.0         |
> | UNLINE  |      断开连接关系      |      1.0****       |
>
> - **其中最常用的就是GET和POST方法**



## # HTTP的状态码

> |      |               类别               |          原因短语          |
> | :--: | :------------------------------: | :------------------------: |
> | 1XX  |  Informational（信息性状态码）   |     接收的请求正在处理     |
> | 2XX  |      Success（成功状态码）       |        请求处理完毕        |
> | 3XX  |    Rediection（重定向状态码）    | 需要进行附加操作以完成请求 |
> | 4XX  | Client Error（客户端错误状态码） |     服务器无法处理请求     |
> | 5XX  | Server Error（服务器错误状态码） |     服务器处理请求出错     |
>
> - **常见的错误码**
>   - 200(OK),404(Not Found),403(Forbidden),302(Redirect重定向),504(Bad Gateway)
>   - 重定向
>     - 302,307：临时重定向
>     - 301：永久重定向



## # HTTP常见的报头

> - **Content-Type**
>   - 数据类型
> - **Content-length**
>   - 正文的长度（长链接下需要知道正文的长度）
> - **Host**
>   - 客户端告诉服务器所请求的资源是在那个主机的那个服务器上
> - **referer**
>   - 当前页面是从那个页面跳转过来的
> - **location**
>   - 搭配3XX状态码使用，告诉客户端接下来要去哪里访问呢
> - **Cookie**
>   - 用于客户端存储少量的信息，通常用于实现会话（Session）的功能。存放账号密码，昵称，基本信息
>   - **好处**
>     - 再次登陆的时候服务器的时候就会把Cookie文件带上就不需要再次输入账号和密码了
>   - **坏处**
>     - 来一个木马病毒，把Cookie文件带走了，然后放到自己的服务器所存储的文件中，病毒登陆的时候直接把Cookie文件也带上去，登录服务器就不需要密码了这样密码就会被盗了
>     - **解决方法：**把账号和密码放到服务器上，让服务器给客户端返回一个Session ID，这个ID存储到自己的Cookie中，每次登陆的时候使用ID获取密码登录。虽说还是可以被盗号，但是对于Session ID有着自己的存活周期，过几个小时就没有了，就无法登录了对被人来说。但是对于自己再次登录需要账号和密码
> - **keep-alive**
>   - 长链接（是否正常链接）
>   - 对于旧版的浏览器拿网页要拿五张照片的话，必须依次一次一次一张照片的拿过程是这样的
>   - 建立连接->那资源->断开连接，循环执行，再次建立连接。这样的话就会导致建立多次连接，对于建立连接是需要成本的，所以这样的话就会导致浪费较多的成本
>   - 而对于长链接就是每次建立一个TCP连接，可以在这一个TCP连接上发送多条消息，不会让发送一次消息就断开连接再次重新连接。这样的话，就会大量减少建立连接所造成的成本损耗，即TIME_WAIT的状态连接少了。减少了系统内核调用，socket的accept()和close()的调用。
>   - 使用keep-alive必须要将keep-alive timeout时间设置好。
>   - http的守护进程一般都提供了keep-alive timeout时间设置参数。
>   - **keep-alive timeout**：一个HTTP产生的TCP连接传输完最后一个响应后，还需要保持住keep-alive timeout秒后，才开始关闭这个链接。
>   - 也就是当HTTP守护进程发送完一个响应之后，理应马上主动关闭响应的TCP连接，设置keep-alive timeout后，HTTP守护进程会说：”再等等看，看浏览器还有没有请求发送过来“，这一等就是keep-alive timeout时间。如果守护进程在这个等待的时间里，一直没有收到浏览器发送过来的请求，就关闭这个链接
>   - **对于keep-alive模式下，如何确定响应的数据已经接收完了呢？**
>     - 使用Content-Length表示正文长度，客户端（服务器）可以根据这个值来判断数据时候接收完毕
>
> - **Accept**
>   - 对于服务器来说，可以接受哪些资源





## # 最简单的HTTP服务器

> 实现一个简单的HTTP也就是对于**应用层只需要遵循HTTP协议**，对于**传输层使用TCP协议**就好了
>
> - **应用层遵循HTTP协议**
>   - 也就是对于**客户端和服务器端发送的消息必须是HTTP协议的请求和响应报文**
> - **传输层遵循TCP协议**
>   - 也就是对于客户端和服务器端传输消息的方式必须是**先建立连接才能发送消息**
>
> 实现一个可以在**Web端可以输出一个hello world的消息**
>
> **代码链接：**



## # 知识点

> - **空行可以判断报头读完了吗，Content-Length用来判断正文读完了吗**
> - **一个端口号每次只能被一个进程所绑定**
>   - 由TIME_WIAT体现出来
>   - 当关闭一个服务器的时候，不能立马再次启动这个服务器，这是因为该服务器处于TIME_WAIT状态，对于端口号还没有释放呢，所以无法立马再次启动相同端口号的服务器
>   - **解决方法：**
>     - 使用端口复用，**调用setsockopt()函数**就可以了









