Linux框架：
	基本认识/命令操作

常用工具：

​	vim:12种模式：3种常用的

​	gcc/g++：编译文件的四个过程

​	makefile：

​	gdb：打断点：给当前文件的一行打断点

​				 给其他文件的某一行打断点

​				 给函数打断点

​				 给一个变量打断点：display/watch

​				查看函数调用栈：breaktrace（bt）

​	yum

进程概念：

​	冯诺依曼/操作系统定位/进程/

​	进程：

​	用户的角度：运行中的程序，

​	操作系统的角度：PCB（task_strcut）

​	ps进程相关的命令:ps -aux -eL -ajx

​	top命令/df命令磁盘/free命令内存

​	Linxu下的进程有7种状态：

所有的信号都被阻塞吗？

​	僵尸状态：一个进程退出之后，操作系统捕捉到这个进程退出，就会给这个进程的父进程发送SIGCHID信号，父进程接收信号之后，没有获取子进程的退出状态

​	僵尸进程的避免：

​	优先级： 

​	程序地址空间：一个进程的内存描述符（虚拟地址空间）

​	进程调度：调度PCB

进程控制：

​	进程创建：

​	进程终止：

​	进程等待：

​	程序替换：

基础IO：

​	系统调用接口：

​	文件描述符：

​	重定向：改变这个文件描述符对应的文件

​	文件系统：

​	软硬链接：ls -l：查看一个文件的是否是软链接

​	动态库/静态库：如何生成

​		静态库：ar -rc

​		动态库：-fPIC （位置无关码）-shared（产生共享库）

进程间通信：原理是什么，如何使用。使用场景是什么

​	管道：

​		匿名管道：

​		命名管道：

​	消息队列：

​	信号量：

​		同步和互斥：如何实现同步和互斥

​	共享内存：

管道是内核提供的一块缓存区，操作的时候需要到内核态写数据和读数据，

而对于共享内存是将内核的一块缓存区映射到了用户态，读写数据的时候直接在用户态不用到内核态

信号：

​	Linxu下的信号是软中断：中断当前的操作，通知发生了进程发生了什么事情

​	中断有软中断和硬中断：

​	信号的生命周期：产生->注册->注销->处理

​	用户态进入内核态：中断，异常，系统调用

​	可重入函数/不可重入函数：能不能被多个线程操作/看有没有全局变量和原子操作

线程多线程：

​	Linxu下的线程是用PCB模拟描述的

​	ps下直接看到的是LWP（轻量级进程），

​	线程创建：

​	线程终止：

​	线程等待：

​		如果线程处于join_able状态就需要被等待

​	线程分离：

​		告诉操作系统直接将资源进行回收，所以就不需要进行等待

​	线程安全：

​		如何保证线程对于数据的操作是处于安全的

​		同步与互斥实现线程安全：

​			同步与互斥的概念

​			互斥保证操作安全但是不能保证资源平均分配

​			死锁：

线程一直拿不到锁，从而一直处于等待状态

​			死锁的产生的四个必要条件：

​				产生：

​					互斥

​					不可剥夺

​					占有且等待

​					循环等待

​				预防：避免产生四个条件

​				避免：银行家算法和有序加锁

​			同步：条件变量/信号量

​			生产者与消费者模型：解耦合，支持并发，支持忙闲不均

​			读写锁：

​			线程池：一个或者多个线程加上一个任务队列

​					作用：

​						防止过度消耗资源

​						避免大量线程频繁创建/销毁成本

​			线程安全的单例模式：



网络：

​	网络发展背景

​	网络通信协议：网络通信中数据格式标准的约定

​	协议分层：OSI七层参考模型，TCP/IP五层模型

​	应用层：应用程序之间的沟通

​		应用程序：程序员写的程序，供用户使用

​		沟通：

​		自定制协议：结构化数据传输：

​			序列化：将很多的数据进行排序和处理，变成一个有序的序列

​			反序列化：

​			举例：结构体

​		知名协议：HTTP协议的数据结构就是协议的格式

​				协议格式：

​		请求头：首行和头部

​			首行：

​				请求：请求方法 URL 协议版本\r\n 

​				响应：协议版本	状态码	状态码描述

​			头部：

​				头部的长度取决于服务器可以接受

​				key: val\r\nkey: val\r\n

​			POST/GET

​			URL：协议//服务器地址：端口/资源路径？查询字符串#片段标识符

​			查询字符串URL转码：

​			字符串：key=val&val=val，采用&进行连接

​		请求行：空行：间隔头部和正文

​		请求体：正文

​	传输层：端与端之间的数据传输

​		端口号：表示主机上的进程，为什么不使用进程ID，因为进程ID会改变

​		字节序：CPU对内存中的数据进行读取的时候，采用的顺序

​			大端字节序：

​			小端字节序：			

​		网络字节序：大端字节序

​		什么样的字节需要转换：大于1个字节的数据，在小端机中，向网络中发送数据的时候，必须要进行转换

​		TCP：

​			面向连接 可靠传输 面向字节流

​			三次握手第三次失败：不是超时重传，服务器端会发送一个resert请求，告诉客户端这个链接不合法，然后断开连接

​			可靠传输：确认应答机制：超时重传机制，校验和，序号/确认序号

​			效率：滑动窗口机制：流量控制，拥塞控制（慢启动/快增长），快速重传

​		UDP：	

​			无连接 不可靠 面向数据报