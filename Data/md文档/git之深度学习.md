# Git之深度学习

---

## Git是追踪文件修改的分布式版本控制系统

## 1. git的来源

> 最先开始linus写出了开源项目linux那个时候就有许多人对于linux进行修改和完善，然后提供给linux这个组织，然后由该组织进行对linux的完善和修改。最后随着时间的增加，越来越多人都提交对linux的修改，所以这个组织也就忙不过来了。这个时候就要弄一个分布式的版本控制工具，这个时候收费的bitmover公司就免费提供了自己的bitkeeper分布式版本控制工具，供linus使用，但是就有好多厉害的人 来破解bitkeeper的协议，然后bitmover公司就不免费提供了，然后linus进行道歉，随后linus就自己花了两周的时间写出了一个自己的分布式版本控制工具，这就是git的产生了
>
> - 2008年，GitHub网站上线了，他为开源项目免费提供Git存储，无数开源项目开始迁移到GitHub



## 2. 集中式版本控制系统和分布式版本控制系统

> 集中式版本控制系统，版本是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活之后，再把自己做的东西推送给中央服务器。
> 集中式版本控制系统就是只有一个中央服务器，如果这个中央服务器坏掉的话，就所有人都没有办法干活了。
>
> 集中式版本控制系统最大的坏处就是需要联网才能工作。
>
> 和集中式版本控制系统相比，分布式版本控制系统的安全性要高得多，因为每个人的电脑上都有一个完整的版本库，某个人的电脑坏掉没有关系还可以从其他人的那里进行复制。



## 3. 在windows下下载git以及配置

> 对于在windows下安装git
>
> 安装完成后，在开始菜单中可以找到“Git->Git bash”,弹出一个类似于命令框的东西，就说明Git安装成功了！
> 安装成功后，还需要·进行最后一步的配置，在命令行输入：
> 	git config --global user.name "Your Name"
> 	git config --global user.email "email@example.com"
>
> 此用户名和邮箱是git提交代码时用来显示你身份和联系方式的，并不是github用户名和邮箱
> 如果你没有进行配置的话，在每次使用git的时候就会提示：please tell me who you are 
>
> 因为git是分布式版本控制系统，所以，对于每个机器都自报家门：你的名字和你的email地址。
>
> 注意git config后的”--global“参数，用了这个参数，表示你这台机器上的所有git仓库都会使用这个配置
> 当然也可以对某个仓库指定不同的用户名和email地址。



## 4. git的三板斧

> - git add
>   - 将工作区下的文件添加到暂存区
> - git commit -m
>   - 将暂存区下的文件一次性全都添加到本地仓库
> - git push -u origin master 
>   - 将本地仓库的所有文件同步到远程仓库



## 5. 时光穿梭机 

> - git status命令
>   - 时刻告诉我们仓库当前的状态
> - git diff（查看difference）
>   - 可以查看当前文件都有哪些修改
>
> **【总结】：**
>
> - 要随时掌握工作区的内容可以使用**` git status`** 命令
> - 如果**` git status`**告诉我们有文件被修改过，用**` git diff`**查看修改的内容



### 5.1 版本回退

> - 对于在实际当中我们可能提交了许多次的一个文件，我们每一次提交的时候都保存了一个快照，这个快照就叫做**` commit`**。一旦把文件误删了或者把文件改乱了，还可以从最近的一个**` commit`**恢复,然后继续开始工作。
> - 对于这么多的修改我们肯定记不住，所以就可以使用` git log`命令来查看**最近到最远的提交日志**，如果对于**` git log`**命令。嫌弃**`git log`**命令输出太长的话，可以加上**`--pretty=oneline`**参数
>
> **【注意】**
>
> - 当看到一大串类似**` 1092bhjghs`**的是**` commit id`**（版本号），和SVN不一样，Git的**`commit id`**不是1,2,3.......递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。
> - 为什么**`commit id`**需要用这么一大串的数字表示呢，因为git是一个分布式版本控制系统，如果大家都用1、2、3......作为版本号，那肯定就冲突了
>
>  
>
> 首先，Git必须知道当前版本是哪一个版本，在Git中，用**`HEAD`**表示当前版本，也就是最新提交的版本，上一个版本就是**`HEAD^`**,上上一个版本就是**`HEAD^^`**,如果需要找到以前的100个版本呢，就可以使用**`HEAD~100`**。
>
> - ```
>   //回到上一个版本
>   git reset --hard HEAD^
>   ```
>
> - ```
>   //回到指定的版本1094a
>   git reset --hard 1094a
>   ```
>
> - 版本号没有必要写完全，只需要写前几位就好了
>
>  版本回退的优点：
>
> - 版本回退的速度非常的快，因为在GIt内部有一个指向当前版本的**`HEAD`**指针，当你回退版本的时候，Git仅仅是把**`HEAD`**重新指定即可
> - 然后顺便把工作区进行更新了，所以你让**`HEAD`**指向那个版本号，就是把当前版本定位在哪
>
>  
>
> **【回退之后要想再次回去该怎么办呢】**
>
> - 这是你可以使用**`git reflog`**，用来记录你的每一次命令
>
> **【小结】**
>
> - **`HEAD`**指向的版本就是当前的版本，因此Git允许我们在各个版本之间来回穿梭，使用命令**`git reset --hard commit_id`**
> - 穿梭前，可以用**`git log`**可以查看提交的历史，以便确定要回到那一个版本
> - 要重返未来，用**`git reflog`**查看命令历史，以便确定要到未来的那个版本



### 5.2 工作区与暂存区

> Git和其他版本控制系统如SVN的一个**不同之处**就是有**暂存区**的概念
>
> **【名词解释】：**
>
> - 工作区（Working Directory）
>   - 就是在电脑可以看到的目录
> - 版本库（Reposity）
>   - 工作区有一个隐藏的目录**`.git`**,**这个不算工作区，而是Git的版本库**
>   - Git的版本库里面存放了许多的东西，其中最重要的就是**被称为stage（或者index）的暂存区**，还有GIt为我们自动创建的第一个分支**`master`**，以及指向**`master`**的一个指针叫做**`HEAD`**。
>
> **【深入理解add和commit】**
>
> - **`git add`**，实际上就是将**工作区的文件修改**添加到**暂存区**
> - **`git commit`**，实际上就是把**暂存区**的**所有内容**都**提交**到**当前分支**
>   - 因为我们创建Git版本库的时候，Git自动为我们创建了唯一一个**`master`**分支，所以现在，**`git commit`**就是往**`master`**分支提交更改
>
> **【小结】**
>
> - **需要提交的文件修改都放到暂存区**，然后**一次性提交暂存区的所有修改到分支**
> - **`git add`** **命令实际上就是把要提交的所有修改放到暂存区**，然后，执行**`git commit`** **一次性将暂存区的所有修改提交到分支**



## 6. 管理修改

> Git比其他的版本控制系统好的地方在于，**Git跟踪并管理的是修改**，而不是文件
>
> **【修改】：**
>
> - 比如你新增了一行，这就是一个修改
> - 删除了一行，这也是一个修改
> - 更改某些字符，删了一些增加一些，这些都是修改
> - 甚至**创建一个文件**，**这也是一个修改**
>
> 对于一个文件：
>
> - 第一次修改->**`git add`**->第二次修改->**`git commit`**
> - 使用**`git status`**可以看到版本库例只是第一次修改的，对于第二次修改的没有提交到版本库
> - 原因：
>   - 使用**`git add`**命令后，**在工作区第一次修改被放到暂存区，准备提交，但是在工作区的第二次修改并没有放到暂存区**，所以**`git commit`** **只负责把暂存区的修改提交了，也即使第一次的修改被提交了，第二次的修改不会被提交。**
> - 提交后，可以使用 **`git diff HEAD -- <文件名>`**命令可以**查看工作区和版本库里面最新版本的区别**
> - 那如何提交第二次修改呢？
>   - 可以继续**`git add`**再**`git commit`**，也可以先别着急提交第一次修改，先**`git add`**第二次修改，再**`git commit`**，就相当于把两次修改合并一块提交了
> - 第一次修改->**`git add`**->第二次修改->**`git add`**->**`git commit`**
>
> **【总结】**
>
> - 对于每次修改，如果不用**`git commit`**到暂存区，那就不会加入到**`git commit`**中。



## 7. 撤销修改

> - 当你乱修改了工作区某个文件的内容，想直接丢弃工作区的修改，用命令**`git checkout -- <file>`**
> - 当你不断改乱了工作区某个文件的内容，还添加到了暂存区，想丢弃修改时，分为两步
>   - 第一步，使用命令**`git reset HEAD <file>`**
>     - 自己对于**`git reset HEAD <file>`**的理解
>     - **这个就相当于将暂存区的这个文件，从暂存区中再次拿出来放到工作区中**
>   - 第二步，使用命令**`git checkout -- <file>`**
> - 当把不合适的修改已经添加到版本库的时候，想要撤销本次提交，可以使用**版本回退**



## 8. 删除文件

> - 一般情况下，通常直接在文件管理器中把没用的文件删了，或者用**`rm`**命令删除了
>
> - 这个时候，Git知道你删除了文件，因此工作去和版本库就不一致了，**`git status`**命令就可以告诉你哪些文件被删除了。
>
> - 这个时候有两种选择：
>
>   - 第一种：删除
>   - 使用命令**`git rm <file>`**，并且**`git commit `**就可以删除
>   - 【提示】：使用**`git rm <file>`**和**`git add <file>`**是一样的效果
>
>   - 第二种：删错了，要恢复
>   - 因为这个时候版本库里面还有呢，所以可以使用版本库里的恢复
>   - 使用命令**`git checkout -- <file>`**
>   - **`git checkout`**其实使用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”
>
> **【总结】**
>
> - 命令**`git rm <file>`**用于删除文件，如果一个文件已经别提交到版本库，那么就永远不用担心误删，但是要小心，只能恢复到最新版本。

