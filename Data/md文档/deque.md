# deque

----

## 1. deque概念

> - **双端队列**
> - vector是单向开口的连续性线性空间，deque则是一种双向开口的连续性线性空间。所谓双向开口，意思就是在头尾两端都可以做元素的插入和删除操作。
> - 对于vector也可以在头尾两端进行操作，但是对于头部操作效率极差，无法被接受



## 2. deque与vector的差异

> - deque允许在常数时间内对头端进行元素的插入和删除操作
> - deque没有所谓容量的概念，因为其实以动态连续的空间组合而成的，随时可以增加一端新的空间并链接起来。



## 3. deque的随机访问

> 虽然deque也提供**Ramdon Access Iterator**，但他的**迭代器并不是不同的指针**，其复杂度不可和vector相比。除非必要我们应尽可能选择使用vector而非deque。对于**deque进行的排序操作，为了最高效率，可以先deque先完整复制到一个vector身上，将vector排序后，在复制回deque。**



## 4. deque的底层实现

> deque具有中控器（map）和缓存区（buffer）以及迭代器（iterator）
>
> - 中控器（map）：**是一个二级指针**，指向的是一端连续的地址空间，每一个空间里面存放的都是以个地址，该地址是一段类型为T的空间（连续性的线性空间）
> - 缓存区（buffer）：一段连续的线性空间，存储数据
> - 迭代器（iterator）：每一个迭代器中有着四个指针
>   - cur：指向当前缓存区的当前元素
>   - first：指向当前缓存区的第一个元素
>   - last：指向当前缓存区的最后一个元素的下一个位置
>   - node：指向管控中心map
> - start(iterator)：存放的是指向第一个buffer的迭代器
> - end(iterator)：存放的是指向最后一个buffer的迭代器



## 5. 常用deque的地方

> 对于deque的使用是在**做stack以及queue的适配器的时候**经常使用deque，这是因为对于deque，其头插尾插的效率高，并且stack和queue都是对于头和尾进行操作，所以可以使用deque，作为其适配器
>
> - 对于stack和queue不需要遍历（所以没有迭代器），只需要在固定的一端或者两端进行操作就可以了
> - 在stack中元素增长的时候，deque的增长效率比vector高；对于queue中，元素增长时，deque不仅效率高而且内存使用率高



## 6. 优缺点

> - 头插尾插效率高
> - 随机访问效率不够好（必须先计算start里面有几个数据，在计算）
> - 插入，有两张解决办法
>   - 移动后面所有的的中控，所控制的buffer
>   - 增大某一个buffer
> - 中间插入没有优势
>
> **【总结】**
>
> - 为什么会出现deque呢，这是因为对于vector和list都有着自己的缺点，所以就出现了deque
> - 想让其既可以支持随机访问，并且对于某一位置的元素进行插入和删除操作的时候的时间复杂度变得低一点，所以就会出现deque。
> - 但是双端队列的随机访问也需要进行自我计算，因为地址空间也不是连续的，是在堆上各处开辟的空间，虽说可以支持随机访问，但是对于随机访问的效率还是太低了。
>   - 需要计算start里面有几个元素，并且要知道每一个buffer多大，有时候有可能进行插入操作的时候，是采取buffer的方法来进行插入的，这就对于随机访问产生了阻碍，导致效率降低



## 7. 知识扩展

### 7.1 仿函数

> - **仿函数也叫作函数对象**
>
> - 仿函数实际也就是一个class类，只不过该类只有一个对于运算符()括号重载的的函数，使用该函数进行比较等功能
>
> - 例：
>
> - ``` c++
>   template <class T>
>   class less
>   {
>   public:
>   	bool operate() (const T& d1, const T& d2)
>       {
>           return d1 < d2;
>       }
>   }
>   
>   template <class T>
>   class greater
>   {
>   public:
>   	bool operate() (const T& d1, const T& d2)
>       {
>           return d1 > d2;
>       }
>   }
>   ```
>
> - 对于**仿函数必须创建一个对象**，然后**让该对象使用()**,就可以进行比较了
>
> - **less（d1, d2）**
>
> - 这看起来像一个函数，**实际上是一个对象**，只不过是对于()进行了重载而已
>
> - 所以也称作其叫做**函数对象**



### 7.2 模板

> 对于模板要记住一个重要的东西，那就是**模板没有代码**
>
> 在使用模板的时候，只有当我们**实例化之后模板才有了自己的代码，**
>
> - 并且对于模板的实例化是**按需实例化**，需要那一段代码的时候在实例化那一端代码
> - 如果不需要的话，就不需要对其进行实例化。
> - **所以有的时候对于模板写错的话，但是没有用到那一段代码，在程序运行的时候也是不会出错的**



### 7.3 适配器

> **适配器是一种设计模式。**
>
> - 该模式就是**将一个接口封装成另外的一个接口**
>
>  
>
> **【为什么将stack，queue，priority_queue称作容器适配器】**
>
> - 虽然对于stack,queue,priority_queue也可以存放元素，但是STL并没有将其划分在容器的行列，而是将其称为**容器适配器**。这是因为对于每一个容器在底层的实现方式都是不同的，而stack,queue,priority_queue这是在底层对于其他的容器进行了封装而已。
>
> - ``` c++
>   template <class T, class Contanier = deque<T> > class stack;
>   
>   template <class T, class Container = deque<T> > class queue;
>   
>   template <class T, class Container = deque<T>, class Compare = less<typename Container::value_type> > class priority_queue;
>   ```
>
> - 这就是对于stack,queue,priority_queue的底层声明
>
> - 可以看出这三个全都是在deuque上进行封装的



### 7.4  vector与list的优缺点

> **对于vector**
>
> - **优点**
>   - 缓存利用率比较高（高速缓存）
>   - 随机访问
> - **缺点**
>   - 在任意位置的插入和删除操作，需要移动大量的元素，时间复杂度为O(N)
>
> **对于list**
>
> - **优点**
>   - 任意位置的插入和删除，时间复杂度为O(1)
> - **缺点**
>   - 不支持随机访问呢
>   - 缓存利用率低
>   - 容易产生内存碎片