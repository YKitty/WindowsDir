# 网络层

-----

## 1. 基本概念

**主机：**配有IP地址，但是不进行路由控制的设备

**路由器：**配有IP地址，又能进行路由控制

**结点：**主机和路由器的统称

**网络层：地址管理和路由选择**



## 2. IP协议

插图：**IP报文首部**

![](F:\WindowsDir\img\网络层\报头.jpg)

### 2.1 4位版本号（Version）

指定IP协议的版本，对于IPV4来说是4

### 2.2 4位首部长度（IHL：Internet Header Length）

IP头部长度的单位是32位也就是4个字节，对于4位可表示的最大的数字就是15，所以最大的头长度60个字节，15 * 4 = 60

### 2.3 8位服务类型（TOS：Type OfnService）

三位优先权（已经弃用），4位TOS字段和一个保留字段（必须置0），最小延迟，最大吞吐量，最高可靠性，最小成本（四个只能选择一个每次）

### 2.4 16位总长度（Tatal Length）

IP数据报整体占多少个字节 ，由于有16位，最多是65536字节。

**目前还不存在能够传输最大长度为65535字节的IP包的数据链路。不过，由于IP分片处理，从IP的上一层的角度来看，不论底层采用何种数据链路都可以认为能够以IP的最大包长传输数据**

### 2.5 16位标识（ID：Identification）

唯一的标识主机所发送的报文，如果IP报文在数据链路层被分片了，那么每一个片里面的这个id都是相同的。

同一个分片的标识值相同，不同分片的标识值不同。通常每发送一个IP包，它的值会逐渐增大。此外，即使ID相同，**如果目的地址，源地址和协议不同的话，也会被认为是不同的分片**

### 2.6 3位标志位（Flags）

第一位保留，第二位置1标识禁止分片，这时候报文超过MTU，IP报文就会被丢弃。**第三位表示“更多分片(more fragment)”，如果是1的话表示是分片中段的包，0最后一个分片的包**。**第二位表示“不要分片(don't fragment)”,1表示不能分片，0表示可以分片**

### 2.7 13位片偏移（Fragment Offset）

是分片相对于原始IP报文开始处的偏移。其实就是在表示当前分片在原报文中的那一个位置。单位为8字节。因此，**除了最后一个报文之外，其他报文的长度必须是8的整数倍**（否则报文就不连续了）。**由于FO占13位，因此最多可以表示8219 = (2 ^ 13)个相对位置。最大可表示原始数据8*8192 = 65536个字节的位置**

### 2.8 8位生存时间（TTL：Time To Live）

**数据报到达目的地的最大报文跳数，一般是64**.每次经过一个路由器，TTL -= 1（减一），一直减到0还没到达的话，那么就丢弃了。这个字段主要**防止出现路由循环**。最初的意思就是以秒为单位记录当前包在网络上应该生存的期限。**TTL是8位，因此可以表示0~255的数字，因此一个包的中转路由的次数不会超过256个。**

### 2.9 8位协议（Protocol）

表示IP包上层使用协议编号（一般是传输层的UDP或者TCP协议）

| 分配编码 |  简称  |
| :------: | :----: |
|    0     | HOPOPT |
|    1     |  ICMP  |
|    2     |  IGMP  |
|    4     |   IP   |
|    6     |  TCP   |
|    8     |  EGP   |
|    9     |  IGP   |
|    17    |  UDP   |
|    41    |  IPv6  |

### 2.10 16位头部校验和（Header Checksum）

使用CRC进行检验，来鉴别头部是否损坏

### 2.11  32位源IP地址（Source Address）

表示发送端IP地址

### 2.12 32位目的IP地址（Destination Address）

表示接收端IP地址

### 2.13 可选项（Options）

长度可变，通常只在进行试验或诊断是使用

- 安全级别
- 源路径
- 路径记录
- 时间戳

### 2.14 填充（Padding）

也叫作填补物，在有可选项的情况下，首部长度可能不是32比特的整数倍。为此通过向字段填充0，调整为32比特的整数倍

### 2.15 数据（Data）

存入数据，将IP上层协议的首部也当做数据进行处理

### 2.16 IP属于面向无连接型的

IP面向无连接。即在发包之前不需要与对端目标地址建立连接。上层如果遇到需要发送给IP的数据，该数据会立即被压缩成IP包发送出去。

对于一台主机来说，他如何从哪里接收数据也是不得而知的，通话应该进行网络监控，让主机只接收发给自己的数据包。若没有组好准备很有可能错过一些该收的包。因此，在面向无连接的方式下可能会有很多冗余的通信**。**

**【问题】：**

1. **为什么IP要采用面向无连接呢？**

- **一个简便化**
- **二是高速化**

面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。此外，每次通信之前都要事先建立连接，又会降低处理速度。需要有连接时，可以委托上一层提供此项服务。因此，IP为了实现简单化和高速化采用面向无连接的方式。

2. **为了提高可靠性，上一层的TCP采用面向有连接型**

IP提供尽力服务，意指“为了把数据包发送到最终目的地址，做最大的努力”。因此提高通信的可靠性很重要。TCP就提供这种服务。**如果说IP只负责将数据发给目标主机，那么TCP则负责保证对端主机确实接收到数据**

**网络通信中如果能进行有效的分层，既可以明确TCP和IP协议各自的最终目的。有利于后续对这些协议进行扩展和性能上的优化。分层简化了每个协议的具体实现。**



## 3. 网段划分（地址管理）

**IP地址：网络号和主机号**

**网络号：**保证相互连接的网段不能就有相同的网络号

**主机号：**同一网段，主机之间具有相同的网络号，但是不能具有相同的主机号

**子网：**就是把网络号相同的主机放在一起

**【注意】**:如果在子网中新增一台主机，则这台主机的网络号和子网的网络号一致，但是主机号必须不能和子网中的其他主机重复

**通过合理的设置主机号和网络号就可以保证在相互连接的网络中，每台主机的IP地址都不相同**

**【问题】：**对于手动管理子网的IP地址，是一个相当麻烦的事情？

**解决方法：**

- **DHCP（动态分配IP地址）**存在于路由器上，动态给主机分配IP地址，更加方便安全给局域网主机分配地址。这就是为什么**主机上一般都设为自动获取IP地址，防止IP地址重复** 

### 3.1 早期网络划分方案

插图：**IP地址的划分**

![](C:\Users\0\Pictures\Linux网络\网络层\五类网络.png)

A类：0.0.0.0到127.255.255.255

B类：128.0.0.0到191.255.255.255

C类：192.0.0.0到223.255.255.255

D类：224.0.0.0到239.255.255.255

E类：240.0.0.0到247.255.255.255

**随着Internet的飞速发展，对于大多数组织都申请B类地址，导致B类地址很快就分配完了，而A类地址却浪费了大量的地址**

**原因：**申请一个B类地址，理论一个子网上能允许6万5千多个主机，A类地址子网内浪费的主机数更多了。但是在实际网络中，不会存在**一个子网内有这么多的情况，因此大量的IP地址都被浪费了**

**解决方案：**

**CIDR（Classless Interdomain Routing）无类域间路由——子网掩码和地址相与得到网络号方式**

- 引入一个额外的子网掩码（subnet mask）来区分网络号和主机号
- 子网掩码也是32位的正整数。通常用一串“0”来结尾
- 将IP地址和子网掩码进行“按位与”就可以得到网络号
- 网络号和主机号的划分与这个地址是A类、B类和C类无关

**CIDR主要就是提高了IP地址的利用率，但是IP地址的上限没有增加**

**【举例】：**

|    IP地址    |        140.252.20.68         |
| :----------: | :--------------------------: |
|   子网掩码   |       255.255.255.240        |
|    网络号    |        140.252.20.64         |
| 子网地址范围 | 140.252.20.64——140.252.20.79 |

**【总结】：**IP地址和子网掩码做**“按位与”**可以得到网络号。**主机号从全0到全1就是子网的地址范围**

**IP地址和子网掩码的另外的表示方式：**

**举例：**

​	**140.252.20.68/24,表示IP地址为140.252.20.68，子网掩码的高24位是1，子网掩码也就是255.255.255.0**



### 3.2 特殊的IP地址

1. 将IP地址中的**主机地址全部设定为0，就成为了网络号**，代表这个局域网
2. 将I**P地址中主机地址全部设定为1，就成为了广播地址**，用于给同一个链路中相互连接的所有主机发送数据包。（适用于UDP，对于TCP没有广播）
3. **127.*的IP地址用于本机环回（loop back）测试**，通常是127.0.0.1.这个就是自己本机有着一个虚拟网卡



## 4. IP地址的数量限制

**IP地址（IPv4）是一个4字节32位**的正整数，那么一共只有**2的32次方个IP地址，大概就是43亿左右**，而TCP/IP规定。**每个主机都需要一个IP地址**，这意味着一共只有43亿台主机能接入网络吗？实际上，**由于一些特殊的IP地址的存在，数量远不足43亿；另外IP地址是按照主机台数来配置的，而是每一个网卡都需要配置一个或多个IP地址。**

CIDR在一定程度上缓解了IP地址不够用的问题，但是IP地址的上限没有增加，所以仍然还是不够用。这时三种解决方案。

**解决方法：**

1. **动态分配IP地址：**只给接入网络的设备分配IP地址，因此同一个MAC地址的设备，每次接入互联网中，得到的IP地址不一定相同
2. **NAT技术：网络地址转换**
3. **IPv6：**IPv6并不是IPv4的简单升级版，这是互不相干的两个地址，彼此互不兼容；IPv6用16字节128位来表示一个IP地址；但是目前还没有普及



## 5. 私有IP地址和公网的IP地址

局域网只能使用一些特定的IP地址（私有IP地址），不能想使用那个IP地址就使用那个，有可能发生局域网的网络号和公网的网络号一样了，就有可能会导致局域网中的主机的IP地址和公网中的IP地址一样了。

### 5.1 私有IP地址和共有IP地址

如果**一个组织内部组建局域网，IP地址只用于局域网内的通信，而不直接连接到Internet上，理论上使用任意的IP地址都可以**，但是RFC1918规定用于组建局域网的**私有IP地址**

1. **10.*，前8位是网络号，共16777216个地址**
2. **172.16.到172.31.，前12位是网络号，共1048576个地址**
3. **192.168.*，前16位是网络号，共65536个地址**

**【注意】：**

1. **包含在这个范围中的，都成为私有IP地址，其余的则称为全局IP（或公网IP）**
2. **在不相同的网络中可以能会产生一样的IP地址** 



### 5.2 路由器

路由器中有两个口**：一个是WAN口，一个是LAN口**

**WAN口：是和外网进行通信的，是全局IP，是由互联网进行分配的IP**

**LAN口：是局域网内部进行通信的，局域网IP（子网IP）**

- 一个路由器可以配置两个IP地址，一个是**WAN口IP**，一个是L**AN口IP（子网IP）**
- 路由器LAN口连接的主机，都从属当前这个路由器的子网中
- **不同路由器之间，子网IP都是一样的（通常都是192.168.1.1**），子网内的主机IP地址不能重复，但是子网之间的IP地址就可以重复
- 每一个家用路由器，其实又作为运营商路由器的子网中的一个节点，这样的运营商路由器可能会有很多级，**最外层的运营商路由器，WAN口IP就是一个公网IP了**
- 子网内的主机需要和外网进行通信时，**路由器将IP首部中的IP地址进行替换（替换为WAN口IP），这样逐级替换，最终数据包中的IP地址成为一个公网IP**。这种技术叫做**NAT（Network Address Translation，网络地址转换）**
- 如果我们希望自己实现的服务器程序，能够在公网上被访问到，就需要把程序部署在一台具有外网IP的服务器上，这样的服务器可以在阿里云/腾讯云上进行购买

**飞秋（局域网之间进行通信）：速度很快，因为不需要经过太多的路由**



## 6. 路由选择

在复杂网络结构中，找出一条通往终点的路线

路由的过程：在网络中一跳一跳寻找目的IP主机的过程

一跳：数据链路层中的一个区间，具体在以太网中指从源MAC地址到目的MAC地址之间的帧传输区间

IP数据报的传输：

1. 当IP数据报到达路由器时，路由器会先查看目的IP
2. 路由器决定这个数据包是能直接发送给目标主机，还是需要发送给下一个路由器
3. 依次反复，一直到达目的IP地址

对于如何判定这个数据包该发送到哪里呢？

**解决方法：每个节点内部维护一个路由表**

**【知识点】：**

- 路由表可以使用**route命令**查看
- 如果目的IP命中了路由表，就直接转发即可
- 路由表中的最后一行，主要由下一条地址和发送部分两部分组成，当目的地址与路由表中其他行都不匹配时，就按照缺省路由条目规定的接口发送到下一跳地址

插图：路由表

![](C:\Users\0\Pictures\Linux网络\网络层\路由表.png)

1. 这台主机有两个网络接口，一个网络接口连到192.168.122.0/24网络，另一个网络接口连到192.168.153.0/24网络
2. 路由表的Destination是目的网络地址，Genmask是子网掩码，Gateway是下一跳地址，Iface是发送接口，Flags中的U标志表示此条目有效，G标志表示此条目的下一跳地址是某个路由器的地址，没有G标志的条目表示目的网络地址是与本机接口直接相连的网络，不必经路由器转发

**举例1：**如果发送的数据包的目的地址是192.168.153.3

1. 跟第一行的子网掩码做按位与运算得到192.168.153.0与第一行的目的网络地址不符
2. 在跟第二行的子网掩码做按位与运算得到192.168.153.0，正是第二行的目的网络地址，因此从ens53接口发送出去
3. 由于192.168.56.0/24正是eth1接口直接相连的网络，因此可以直接发送到目的主机上而不需要经路由器转发

**举例2：**如果发送的数据包的目的地址是202.10.12

1. 一次和路由表的子网掩码进行按位与，然后与目的地址进行对比，发现所有的都不匹配
2. 就会按照缺省目录default，从ens33接口发送出去，发往默认网关
3. 由默认网关路由器根据他的路由表决定下一条的地址

**路由表生成算法：**

- **路由表可以由网络管理员手动维护（静态路由），也可以通过一些算法自动生成（动态路由）**



## 7. 数据链路层

**用于两个设备（同一种数据链路节点）之间进行传递**

### 7.1 认识以太网

- **以太网不是一种具体的网络，而是一种技术标准。**既包含数据链路层的内容，也包含了一些物理层的内容。例如：规定了网络拓扑结构，访问控制方式，传输速率
- **以太网的网线必须使用双绞线，**传输速率有10M，100M，1000M等
- **以太网是当前应用最广泛的局域网技术**，和以太网并列的还有令牌环网，无线LAN

### 7.2 以太网帧格式

以太网的帧格式：如下图

插图：以太网的帧格式

![](C:\Users\0\Pictures\Linux网络\网络层\以太网的帧格式.jpg)

![](C:\Users\0\Pictures\Linux网络\网络层\_以太网帧格式.jpg)

- 源地址和目的地址是指**网卡的硬件地址（也叫MAC地址），长度是48位**，是在网卡出厂的时候固化的
- 帧协议类型字段有三种值，分别对应**IP（0800），ARP（0806），RARP（0835）**
- **帧末尾是CRC校验码**



### 7.3 认识MAC地址

- MAC地址用来识别**数据链路层中相连的节点**
- **长度为48位，即6个字节**。一般使用16进制**数字加上冒号的形式来表示**（例如：08::00::27::03::fb::19）
- 在**网卡出厂的时候就确定了，不能修改，MAC地址通常是唯一的**（虚拟机中的MAC地址不是真实MAC地址，可能会有冲突，也有些网卡支持用户配置MAC地址）



### 7.4 对比理解MAC地址和IP地址

- **IP地址描述的是路途总体的起点和终点**
- **MAC地址描述的是路途上的每一个区间的起点和终点**



### 7.5 数据链路的抽象化

**IP是实现多个数据链路之间通信的协议。**

**数据链路地址对于IP地址是形式透明的。**因此对于IP的上一层来说，不论底层数据链路使用以太网还是PPP，还是无线的LAN，都将被一视同仁。

不同的数据链路有着一个最大的**区别就是各自的最大传输单位（MTU：Maximum Transmission Unit）不同**

MTU的值在以太网中是1500字节，在FDDI中是4352字节，而ATM则为9180字节。IP的上一层可能会要求传输比这些MTU更大字节的数据，因此必须**在线路上传输比包长还要小的MTU**

为了解决这个问题，IP进行分片处理（IP Fragmentation）。将较大的IP包分成较小的IP包。分片的包到了对端目标地址以后会再组合起来传输给上一层。即从IP的上层看，他完全可以忽略数据包在途中的各个数据链路上的MTU，而只需要按照源地址发送的长度接收数据报。IP就是以这种方式**抽象了数据链路层，是的上层更不容易看到底层网络构造的细节。**



### 7.6 认识MTU

MTU相当于快递发送是对于包裹尺寸的限制。这个**限制是不同的数据链路层对应的物理层所产生的限制**

- 以太网帧中的数据长度规定**最小是46字节，最大1500字节。**ARP，RARP数据包的长度不够46字节，要在后面补填充位
- **最大值1500称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU**
- 如果一个数据包从以太网路由到拨号链路上，**数据包长度大于拨号链路的MTU了，就要对于数据报进行分片**
- **不同的数据链路层标准的MTU是不同的**



### 7.7 MTU对IP协议的影响

**由于数据链路层MTU的限制，对于较大的IP数据包要进行分包**

- 将较大的IP包分成多个小包，并给每个小包打上标签
- 每个小包IP协议头的16位标识（id）都是相同的
- 每个小包的IP协议头的3位标志字段中，第2位置为0，表示允许分片，第3位表示结束标记（当前是否是最后一个小包，是的话置为1，否则置为0）
- 到达对端时再将这些小包，按顺序重组，拼装到一起返回给传输层
- 一旦这些小包中的任意一个小包丢失，接收端的重组就会失败，但是IP层不会负责重新传输数据

**【问题】：对于分片之后的IP数据报是在对端目标主机进行重组的。**

因为：对于IP数据报无法保证是**经过同一个路径进行传送**的。因此，即使等待片刻，数据报也有可能无法到达目的地。另外，拆分之后的每个分片也有可能在**途中丢失**。所以就无法在途中某一处进行重组。即使在某处进行重组之后，但是如果**下一站再次经过其他路由的话，还是会被分片**的。这会个路由器带来多余的负担，也会降低网络效率。



### 7.8 MTU对于UDP协议的影响

- 一旦UDP携带的数据超过1472（1500 - 20（IP首部）-  8（UDP首部）），那么就会在网络层分成多个IP数据报
- 这些数据报有任意一个丢失，都会引起接收端网络层重组失败，那么这就意味着，如果UDP数据报在网络层被分片，真个数据被丢失的概率就大大增加了



### 7.9 MTU对于TCP协议的影响

- TCP的一个数据报也不能无限大，还是受制于MTU，TCP的单个数据包的最大消息长度，称为MSS
- TCP在建立的时候的过程中，通信双方会进行MSS协商
- 最理想的情况下，**MSS的值正好是IP不会被分片处理的最大长度（这个长度还是受制于数据链路层的MTU）**
- 双方在**发送SYN的时候会在TCP头部写入自己能支持的MSS值**
- 然后双方的MSS进行协商，**MSS之后选择较小的作为最终MSS**
- **MSS的值就是在TCP首部的40字节变长选项中（kind = 2，序号2）**



### 7.10 路径MTU发现

**分片中会对路由器的负担加重，因为路由器的功能越来越多，比如”网络过滤“。所以只要允许是不想使路由器对IP数据包进行分片处理的。**

**“网络过滤”：过滤是指带有一定特殊参数的IP数据报才能通过路由器**。这里的参数可以是发送端的主机，接收端的主机、TCP或UDP的端口号或者TCP的SYN标志或ACK标志

**解决方法：路径MTU发现**

路径MTU是指从发送端主机到接收端主机之间不需要分片是最大MTU的大小。即**路径中存在的所有数据链路中最小的MTU**。路径MTU实现了从发送端主机按照路径MTU的大小将数据报分片之后进行发送。就可以避免在中途的路由器上进行分片处理，也可以在TCP中发送更大的包。

对于**UDP没有重传机制**，在第一次发送的数据报如果太大的话，就会被路由器进行丢包，但是**没有重传机制，这个数据包就会被丢失**。然后**路由器返回一个ICPM报文，告诉主机MTU是多大，然后下一次发送数据报的时候发送小于MTU的**

但是对于**TCP具有重传机制，所以就会进行重传丢失的那个包。不回造成丢包问题。**



### 7.11 如何查看硬件地址和MTU

使用命令**` ifconfig`**



## 8. ARP协议

虽然我们在这里介绍ARP协议，但是需要强调的是，**ARP不是一个单纯的数据链路层的协议，而是一个介于数据链路层和网络层的协议**。**ARP只适用于IPv4，不适用IPv6.。IPv6可以使用ICMPv6替代ARP发送邻居探测消息**

### 8.1 ARP协议的作用

ARP协议建立了**主机IP地址和MAC地址的映射关系**

- 在网络通讯的时候，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址
- 数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机地址不符，则直接丢弃
- 因此在通讯前必须获得目的主机的硬件地址

ARP协议的工作流程：

插图：ARP工作流程

![](C:\Users\0\Pictures\Linux网络\网络层\ARP工作流程.jpg)

- 源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少“，并将**这个请求广播到本地网段（以太网首部的硬件地址填FF::FF::FF::FF::FF::FF表示广播）**
- 所有同一个链路上的所有主机和路由器都可以进行接收，因此ARP请求包可以被这个同一链路上的所有主句和路由器进行解析。目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址写在ARP响应包中，
- 每台主机都**维护一个ARP缓存表**，可以使用**arp -a 命令**查看。缓存表中的表项有过期时间（一般为20分钟），如果**20分钟内没有再次使用某个表项则该表项失效，下次还要发送ARP请求来获得目的主机的地址**
- **ARP缓存表分为动态和静态项目**，**动态表二十分钟刷新一次，静态只有重新启动计算机才会被清除** 

**根据ARP可以动态进行MAC地址解析，因此，在TCP/IP的网络构造和网络通信中无需事先知道MAC地址究竟是什么，只要有IP地址就可以了**

**`arp -a`**对于**UNIX和Windows中可以查看MAC地址和IP地址对应的数据库叫做ARP表**

每执行一次ARP，其对应的缓存内容都会被清除。不过在清除之前都可以不需要执行ARP就可以获取到想要的MAC地址。

- 一般来说，发送过一次IP数据包的主机，继续发送多次IP数据报的的可能性会比较高。因此这种缓存能够有效的减少ARP包的发送。反之，**接收到ARP请求包的那个主机又可以从这个ARP请求包获取发送端主机的IP地址及其MAC地址**。这是他也将这些MAC地址的信息缓存起来，从而根据MAC地址发送ARP响应包给发送端主机。类似的，接收到IP数据包的主机又往往会继续返回IP数据报返回给发送端主机，以作为响应。

### 8.2 ARP数据报格式

插图：ARP数据报格式

![](C:\Users\0\Pictures\Linux网络\网络层\ARP数据报的格式.jpg)

- 注意到源MAC地址、目的MAC地址在以太网首部和ARP请求各出现一次，对于链路层为以太网的情况是多余，但如果链路层是其他类型的网络则有可能是必要的
- 硬件类型指链路层网络类型，1为以太网
- 协议类型指要转换的地址类型，0x0800为IP地址
- 硬件地址长度对于以太网地址为6字节
- 协议地址长度和IP地址为4字节
- **op字段为1表示ARP请求，op字段为2表示ARP应答**



### 8.3 面试题

**【问题】：**

1. **为什么要有缓存表？为什么表项要有过期时间而不是一直有效？**

如果有了缓存表的话，**下一次在向这个主机发送消息的时候就不需要再次发送ARP请求包，而可以直接使用在缓存表中的MAC地址，这样就避免了ARP包在网络上被大量广播的可能性。**并且**不会造成不必要的流量**

不能一直有效是因为不能保证对端是因为**再换网卡的时候或移动笔记本电脑，智能终端时，IP地址和MAC地址的对应关系就会发生改变。**

当**更换网卡的时候，MAC地址就会发生改变；在移动笔记本电脑，智能终端时IP地址就会变动**。所以对于表项一定要有过期时间。保证了MAC地址和IP地址对应关系即使发生了变化，也依然可以将数据包正确的发送给目标地址

2. **IP和MAC地址缺一不可？**

对于有的人可能会说，“在**数据链路**上，**只需要知道接收端的MAC地址不就可将数据发送给接收端了吗**”，还有就是“只要**知道了IP地址，即使不做ARP**，只要在**数据链路**上做一个**广播不就能发给主机B了吗**”，为什么还需要IP地址和MAC地址呢？

但是如果考虑一下，发送给**其他的数据链路**中某一个主机的情况,就会发现上述的方法就不可行了。

采用下图来进行解释？

插图：MAC地址和IP地址的作用不同

![](C:\Users\0\Pictures\Linux网络\网络层\MAC和IP地址的作用不同.jpg)

如图，主机A想要发送IP数据报给主机B时必须经过路由器C。即使知道了主机B的MAC地址，由于路由器C会隔断两个网络，还是无法实现直接从主机A发送数据报给主机B。此时主机A必须先将数据报发送给路由器C的MAC地址C1。

此外假设MAC地址采用广播地址，那么路由器D也将会收到该广播消息。于是路由器又会将消息转发给路由器C，导致数据包被重复发送两次。

**【注意】：为了防止这种现象的产生，目前路由器可以做到将那些MAC地址称为广播地址的IP数据报不进行转发**

在以太网上发送IP包时，“**下次要经由那个路由器发送数据报**”这一消息非常重要。而这里的“**下一个路由器”就是相应的MAC地址**

可以看到，**IP地址和MAC地址两者缺一不可**。**IP地址告诉一个终点方向最后要发送到哪里去，而MAC地址则是告诉每一次要走到哪里，是一个具体的方向**。于是就有了将这两个地址关联的ARP协议了。

**【注意】：**为了避免这个**两个阶段的通信带来过多的网络流量**，ARP具有对IP地址和MAC地址的**映射进行缓存**的功能。有了这个缓存的功能，发送IP包是就**不必每次都发送ARP请求，从而防止性能下降**

最后我们在试想一下，不使用IP地址，而是通过MAC地址连接世界上所有网络中的所有的主机和节点的情况。仅仅凭借一个MAC地址，人们是无法知道这台机器所处的位置的。

**【注意】：**在**使用IP地址的时候可以由网络部分充当提供位置的作用，对地址进行集约**

如果如果全世界的设备都是用MAC地址相连，那么网桥在习得之前就必须向全世界发送包。可想而知那将会造成多大的网络流量。而且由于没有任何集约机制，网桥就不得不维护一张巨大的表格来维护所学到的所有MAC地址。一旦这些信息超过网桥所能承受的极限，那将会导致网桥无法正常工作，也就无法实现通信了。

**【注意】：与之对应的IP地址路由控制表也会变得无比庞大**

**【网桥】：早期的两端口二层网络设备，用来连接不同网段** 

网桥也叫桥接器，是连接两个局域网的一种存储/转发设备，它能将一个大的LAN分割为多个网段，或将两个以上的LAN互联为一个逻辑LAN，使LAN上的所有用户都可访问服务器。 



## 9. RARP协议

**RARP（Reverse Address Resolution Protocol）是将ARP反过来，从MAC地址定位IP地址的一种协议**

**举例：**

​	**将打印机服务等小型嵌入式设备接入到网络时就会经常用到**

平常我们可以通过**个人电脑设置IP地址，也可以通过DHCP自动分配获取IP地址**。然而，对于使用**嵌入式设备**时，会遇到**没有任何输入接口（也就是自己设定IP地址）或无法通过DHCP动态获取IP地址**的情况。

在类似的情况就可以**使用RARP**。为此，需要架设一台**RARP服务器**，从而在这个服务器上**注册设备的MAC地址及其IP地址**。然后再将这个设备接入到网络，插电启动设备时，该**设备就会发送一条“我的MAC地址是###，请告诉我的IP地址应该是什么？”的请求信息。RARP服务器收到这个消息后返回类似于“MAC地址为 ###的设备，IP地址为###”的信息给这个设备。**

**而设备就根据从这个RARP服务器所收到的应答信息设置自己的IP地址。**

**【总结】：**

​	**对于RAPR协议产生的原因就是对于一个接入到网络中的设备无法自己设置自己的IP地址或者无法使用DHCP协议为其分配IP地址所以就需要RARP来为其分配一个IP地址。这个时候需要一个RARP服务器，这个服务器有着MAC地址和IP地址的对应，也就是说这个服务器必须有着这些没有拥有IP地址的设备的MAC地址，并且要为其分配一个IP地址**



## 10. 代理ARP

​	**通常ARP包会被路由器隔离，但是采用代理ARP的路由器就可以将ARP请求转发给临近的网段。由此，两个以上的网段结点之间可以像在一个网段上进行通信**

在目前的TCP/IP网络中，一般情况下用路由器连接多个网络的时候，会在每个网段上定义各自的子网，从而进行路由控制。然后，对于那些不支持设定子网掩码的老设备来说，不使用代理ARP，有时就无法更好的使用网络



## 11. DNS

**DNS一整套从域名映射到IP的系统**

### 11.1 DNS背景

TCP/IP中使用IP地址和端口号来确定网络上的一台主机的一个程序，但是IP地址不方便记忆。为此TCP/IP世界从一开始就有了一个叫做**主机识别码**的东西，这种识别方式是指**为每一台计算机赋以唯一的主机名**。于是人们发明了一种叫做**主机名（域名，每台计算都有一个唯一的主机名）**的东西，是一个字符串，并且使用**hosts文件来描述主机名和IP地址的关系。**

最初，通过**互联网信息中心（SIR-NIC）来管理这个hosts文件的**

- 如果一个新计算机要接入网络，或者某个计算机IP变更，都需要信息中心申请变更hosts文件
- 如果其他的计算机也需要定期下载更新版本的hosts文件才能正确上网

**这样就太麻烦了，于是就产生了DNS系统**

- 一个**组织的系统管理机构**，维护系统内的每个主机的IP和主机名的对应关系
- 如果新的计算机接入网络时，将这个信息注册到数据库中
- 用户输入域名的时候，会自动查询DNS服务器，由DNS服务器检索数据库，得到对应的IP地址

至今，我们的计算机上仍然保留了hosts文件，在域名解析的过程中仍然会优先查找hosts文件的内容

使用命令**`cat /etc/hosts`**命令可以查看hosts文件



### 11.2 域名简介

**主域名（左边的字段），用来识别主机名。**

**域名是为了识别主机名称和组织机构名称具有的一种分层的名称**

域名系统采用层次结构，按地理域或机构域进行分层，用小数点将各个层次隔开，从右到左依次为最高域名段、次高域名段等，**最左的一个字段为主域名** 

举例：

``` c++
www.baidu.com
```

**域名使用 . 连接**

- com：一级域名，表示一个企业域名。统计的还有“net”（）网络提供商，“org”（非营利组织）
- baidu：二级域名，公司名
- www：习惯用法。之前人们使用域名的时候，往往命名成类似于ftp.xxx.xxx.xxx/www.xxx.xxx.xxx这样的格式，来表示**主机支持的协议**

### 11.3使用dig工具分析DNS过程

**安装dig工具**

``` c++
yum install bind-utils
```

**使用dig指令查看域名解析过程**

``` c++
dig www.baidu.com
```

结果如下：

插图：dig查看百度

![](C:\Users\0\Pictures\Linux网络\网络层\dig查看百度.png)

dig 命令默认的输出信息比较丰富，大概可以分为 5 个部分。

- 第一部分显示 dig 命令的版本和输入的参数。
- 第二部分显示服务返回的一些技术详情，比较重要的是 status。如果 status 的值为 NOERROR 则说明本次查询成功结束。 
- 第三部分中的 "QUESTION SECTION" 显示我们要查询的域名。 
- 第四部分的 "ANSWER SECTION" 是查询到的结果。 
- 第五部分则是本次查询的一些统计信息，比如用了多长时间，查询了哪个 DNS 服务器，在什么时间进行的查询等等。 

更多的dig方法

https://www.imooc.com/article/26971?block_id=tuijian_wz



### 11.4 如何根据域名来查找对应的IP地址

使用**nslookup命令**



### 11.5 DNS服务器以及DNS解析过程

再启动域名之前，单凭主机名还无法完全管理IP地址，因为在不同的组织机构中不允许有同名的主机。然后在出现了带有层次结构的域名之后，每一个组织机构就可以自由的为主机命名了。

因为在即使主机名相同但是他们所在的组织不同，所以对外表现也是不同的。

DNS的分层结构。由于看起来像一颗倒挂的树，人们也把这种分层叫做树形结构。如果说顶点是树的跟（Root），那么底下就是树的各层的枝叶。顶点下的第一层叫做**第1层域名（国家和地区顶级域名）**，它包括“jp（日本）”，“uk（英国），”cn（中国）“等代表国家的域名。还包括代表”edu（美国教育机构）“或”com（美国企业）“等特定领域的域名**（国际顶级域名）**。三是**新顶级域名（New gTLD）**如通用的[.xyz](https://baike.baidu.com/item/.xyz/15250717)、代表“高端”的[.top](https://baike.baidu.com/item/.top/8771482)、代表“红色”的.[red](https://baike.baidu.com/item/red/19470580)、代表“人”的.men等一千多种 

域名服务器：

域名服务器是**管理域名的主机和相应的软件**他可以**管理所在分层的域的相关信息。**

插图：域名服务器

![](C:\Users\0\Pictures\Linux网络\网络层\域名服务器.jpg)

**根部所设定的DNS叫做根域名服务器（Root）。其对于DNS的检索功能起着至关重要的功能**。**如果没有根域名服务器对于DNS的查询就会有可能查询不到，从而出错**。根域名服务器中注册这根以下第一层域名服务器的IP地址。如上图根域名服务器中，注册了那些管理的域名服务器的IP地址。反之如果想要**新增一个类似jp或org的域名或修改某个已有域名的IP地址，就得在根域名服务器中进行追加或变更。**

**对于一个域名服务器来说，如果下面再没有其他的分层之后，就可以自由的指定主机名称或子网名称了。**

所以对于**域名和域名服务器都要采用分层来进行设置**。如果域名服务器宕机，那么针对该域的DNS查询也就无法正常工作。因此，**为了提高域名服务器的容灾能力，一般会设置至少两个以上的域名服务器**。**一旦第一个域名服务器无法提供查询的时候，就会自动转到第二个甚至第三个域名服务器上进行工作，由此可以按照顺序进行灾备处理。**

所有的**域名服务器必须注册根域名服务器的IP地址**，因为DNS根据IP地址进行检索的时候，需要从根域名服务器按顺序进行。

**【解析器】：**

**进行DNS查询的主机和软件叫做DNS解析器。用户所使用的工作站或个人电脑都属于解析器。一个解析器至少要注册一个以上域名服务器的IP地址。通常他至少包括组织内部的域名服务器的IP地址。**

**【DNS查询】：**

插图：DNS查询

![](C:\Users\0\Pictures\Linux网络\网络层\DNS查询.jpg)

解析器为了查询IP地址，向域名服务器进行查询处理，接收到这个查询请求的域名服务器首先会**在自己的数据库进行查找**。如果有该域名所对应的的IP地址就返回。如果没有的话，则域名服务器再向**上一层根域名服务器进行查询处理**。因此，从根域名服务器开始按照顺序进行遍历，直到找到指定的域名服务器，并有这个域名服务器返回想要的数据。

**解析器和域名服务器将最新了解的消息保存在缓存中。这样就可以减少每次查询是的性能消耗。**



### 11.6 DNS如同互联网中的分布式数据库 

DNS是一种通过主机名检索IP地址的系统。然而他所管理的信息不仅仅是这些主机名和IP地址之间的映射关系。他还要管理众多的其他信息。

例如：主机名和IP地址的对应信息叫做A记录。反之从IP地址检索主机名的信息叫做PTR。

|   类型    |  编号   |            内容            |
| :-------: | :-----: | :------------------------: |
|   **A**   |  **1**  |  **主机名的地址（IPv4**）  |
|  **NS**   |  **2**  |       **域名服务器**       |
| **CNAME** |    5    | **主机别名对应的规范名称** |
|    SOA    |    6    |   区域内权威记录起始标志   |
|    MKS    |   11    |         已知的服务         |
|  **PTR**  |   12    |     **IP地址反向解析**     |
|   HINFO   |   13    |     主机相关的追加信息     |
|   MINFO   |   14    |       邮箱和邮件信息       |
|    MX     |   15    |          邮件交换          |
|    TXT    |   16    |            文本            |
|    SIG    |   24    |          安全证书          |
|    KEY    |   25    |            密钥            |
|   GPOS    |   27    |          地理位置          |
| **AAAA**  | **28**  |     **主机的IPv6地址**     |
|    NXT    |   30    |         下一代域名         |
|    SRV    |   33    |         服务器选择         |
|   *****   | **255** |      **所有缓存记录**      |



### 11.7 【面试题】：浏览器输入url后，发生的事情

https://blog.csdn.net/wuhenliushui/article/details/20038819/



## 12. ICMP协议

**ICMP是一个网络层协议**

一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通，但是IP新协议并不提供可靠传输，如果丢包了，IP协议不会通知传输层是否丢包以及丢包的原因



### 12.1 ICMP的功能

ICMP正是提供这种功能的协议，ICMP主要功能包括：

- 确认IP包是否成功到达目的地址
- 通知在发送过程中IP包被丢弃的原因
- ICMP也是基于IP协议工作的，但是他并不是传输层的功能，因此人们仍然把他都归结为网络层协议
- ICMP只能搭配IPv4使用，如果是IPv6的情况下，需要用ICMPv6



### 12.2 ICMP的报文格式

插图：ICMP的报文格式

![](C:\Users\0\Pictures\Linux网络\网络层\ICMP的报文格式.gif)

ICMP大概分为两类报文：

- 一类是通知出错原因的错误消息
- 一类是用于诊断的查询信息

| 类型（十进制数） |                 内容                  |
| :--------------: | :-----------------------------------: |
|        0         |        回送应答（Echo Reply）         |
|        3         | 目标不可达（Destination Unreachable） |
|        4         |       原点抑制（Source Quench）       |
|        5         |     重定向或改变路由（Redirect）      |
|        8         |       回送请求（Echo Request）        |
|        9         |  路由器公告（Router Advertisement）   |
|        10        |   路由器请求（Router Solicitation）   |
|        11        |         超时（Time Exceeded）         |
|        17        | 地址子网请求（Address Mask request）  |
|        18        |  地址子网应答（Address Mask Reply）   |



### 12.3 主要的ICMP消息

1. **【ICMP目标不可达消息（类型3）】**

IP路由器无法将IP数据包发送给目标地址时，会给发送到端主机返回一个目标不可达的ICMP消息。并在这个消息中显示不可达的具体原因。

经常使用的是**错误代码1，表示主机不可达**，它是指路由表中**没有该主机的信息**，或者**该主机没有连接到网络**的意思。错**误代码4则用于其前面的MTU探索**。告诉**发送端主机MTU是多大**，下次发送的IP数据报应该小于该数值



2. **【ICMP重定向消息】（类型5）**

如果路由器发现发送端主机使用**了最优的路径**去发送消息，那么他就会**返回一个ICMP重定向消息给这个主机**。这个消息包含了**最合适的路由信息和源数据**。这主要是**应用于路由器持有更好的路由信息的情况**下。路由器会通过ICMP消息发送给端主机一个更合适的发送路由。

如果**路由器在不好的情况**下，比如**不是发送端主机，而是在某个途中的路由器的路由控制表不正确，ICMP可能会导致无法正常工作**

插图：ICMP重定向消息

![](C:\Users\0\Pictures\Linux网络\网络层\ICMP的重定向消息.jpg)

**对于自动追加的消息要在一定期限的时间之后删除，ICMP的重定向消息也会在一定时间之后自动清除的。**

**【注意】：**

**多数情况下，由于重定向消息称为引发问题的原因，所以往往不进行这种设置**



3. **【ICMP超时信息】（类型11）**

对于IP包中有着一个字段叫做**TTL（Time To Live，生存周期）**，他的值**每次经过一次路由器就会减少1**，直到**减到0该IP包会被丢弃**。此时，**IP路由器就会发送一个ICMP超时消息（错误号0）该发送端主机，并通知该包已经丢弃。**

**错误号1表示被拆分的包做重构处理时超时**

**设置IP包生存周期的目的**，是为了发生路由循环的情况下，**避免IP包无休止的在网络上进行转发**。此外有时可以使用**TTL控制包的到达规范，例如设置一个较小的TTL。**

插图：ICMP时间超时消息

![](C:\Users\0\Pictures\Linux网络\网络层\ICMP时间超时消息.jpg)

**【应用】：traceroute&tracert**

使用超时重传消息开发的**tracceroute命令（应用于UNIX和MacOS，对于Windows使用的是tracert）**。他可以**显示出由执行程序的主机到达特定主机之前经历了多少路由器。**

原理：就是利用**IP包的生存周期从开始按照顺序递增的同时发送UDP包**（**为了不会进行发送失败之后再次重发**），**强制接收ICMP超时消息**的一种方法。

这样可以将所有路由器的IP地址逐一呈现。



4. **【ICMP回送消息】（类型0,8）**

用于进行通信的主机和路由器之间，判断所发送的数据包是否已经到达对端的一种消息。可以**向对端主机发送回送请求的消息（类型8），也可以接收对端主机发回来的回送应答消息（类型0）**。网络上的ping命令就是利用这个消息实现的。



**其他ICMP消息**

5. **【ICMP原点消息】（类型4）**

在**使用低速广域线路的情况下，连接WAN的路由器可能会遇到网络拥堵的问题。ICMP原点抑制消息的目的就是为了缓和这种拥堵情况**

当路由器向低速线路发送数据时，其发送队列的残存变为而无法发送出去是，可以向IP包的源地址发送一个ICMP原点抑制消息。收到这个消息的主机借此了解在整个线路的某一处处于拥堵的情况，从而**打开IP包的传输间隔**。然而，**由于这种ICMP消息可能引起不公平的网络通信，一般不被使用。**



6. **【ICMP路由探测消息】（类型9,10）**

**主要用于发现与自己相连网络中的路由器。当一台主机发出ICMP路由器请求（类型10）时，路由器返回ICMP路由器公告消息（类型9）给主机。**



7. **【ICMP地址掩码消息】（类型17,18）**

主要用于**主机和路由器想要了解子网掩码**的情况。可以**向那些目标主机或路由器发送ICMP地址掩码请求消息（类型17），然后通过接收ICMP地址掩码应答消息（类型18）获取子网掩码消息**



### 12.4 ping命令

插图：ping命令

![](C:\Users\0\Pictures\Linux网络\网络层\ping百度.png)

- **ping的是域名，而不是url**！一个域名可以通过DNS解析成IP地址
- ping命令不光能验证网络的连通性，同时也会统计响应时间和TTL（IP包中的Time To Live，生存周期）
- ping命令会先发送一个**ICMP Echo Request给对端**
- 对端收到之后，会**返回一个ICMP Echo Reply**

 插图：回送请求

![](C:\Users\0\Pictures\Linux网络\网络层\回送请求.jpg)

**【注意】：ping命令是处于网络层的**

有些面试官可能会问：telnet是23端口，ssh是22端口，那么ping是什么端口呢？

**ping命令基于ICMP，是在网络层，而端口号，是传输层**的内容，在ICMP中根本就不关注端口这样的信息

**traceroute命令**

**也是基于ICMP协议实现的，能够打印出可执行程序主机，一直到目标主机之前经历多少路由器**



## 13. NAT技术

### 13.1 NAT技术背景

之前我们讨论了。IPv4协议中，IP地址数量不充足的问题

**NAT技术解决当前IP地址不够用的主要手段，是路由器的一个重要的功能**

- NAT能够将私有IP对外通信是转为全局IP，也就是一种**将私有IP和全局IP相互转化的技术方法**
- 很多学校，公司，家庭内部采用**每个终端设置为私有IP，而在路由器或必要的服务器设置全局IP**
- **全局IP要求唯一，但是私有IP不需要**，在**不同的局域网中出现相同的私有IP是完全不影响**的



### 13.2 NAT IP转换过程

插图：NAT工作机制

![](C:\Users\0\Pictures\Linux网络\网络层\NAT.jpg)

- NAT路由器将源地址从10.0.0.10替换成全局的IP 202.244.174.37
- NAT路由器收到外部的数据时，又会把目标地址IP从202.244.174.37替换回10.0.0.10
- 在NAT路由器内部，有一张自动生成的，用于地址转换的表
- 当10.0.0.10第一次向163.221.120.9发送数据时就会生成表中的映射关系



### 13.3 NAPT

问题来了，如果局域网内，有多个主机都访问同一个外网服务器，那么对于服务器返回的数据中，目的IP都是相同的，那么NAT路由器如何判定将这个数据报转发给那个局域网的主机？

这时候NAPT来解决这个问题了，**使用IP+port来建立这个关联关系**

插图：NAPT

![](C:\Users\0\Pictures\Linux网络\网络层\NAPT.jpg)

这种**关联关系也是由NAT路由器自动维护**的。例如**在TCP的情况下，建立TCP连接首次握手时的SYN包一经发出，就会生成这个表。而后随着收到关闭连接时发出FIN包的确认应答从表中删除**

**对于UDP中两端应用进行通信是起止时间不一定保持一致，因此在这种情况下生成转换表相对较难**

### 13.4 NAT技术的缺陷以及解决方法（NAT穿越）

由于NAT依赖这个转换表，所以有诸多限制

- 无法从NAT外部向内部建立连接
- 转换表的生成和建立都需要额外开销
- 通信过程中一旦NAT设备异常需重新启动时，所有的TCP连接都将被重置
- 即使备置两台NAT做容灾备份，TCP连接还是会断开
- 虽然可以指定端口号允许向内部访问，但是数量受到全局IP的地址个数的影响



**【解决】：解决了NAT外部向内部建立连接**

- **第一种方法：改用IPv6。**在IPv6的环境下可用的IP地址范围有了极大的扩展，以至于公司或者家庭当中的所有设备都可以配置一个全局的IP地址了。但是对于IPv6是不兼容IPv4的，所以要是使用IPv6的话，就要所有人都是用IPv6不然就没有作用了。

- 第二种方法：NAT内侧（私有地址的一边）**主机上运行的应用为了生成NAT转换表，需要先发送一个虚拟的网络包给NAT外侧，而NAT并不知道这个虚拟的包是什么，还是会照样读取包首部中的内容并自动生成一个转换表**。这是，如果转换表构造合理，那么还能实现NAT外侧的主机和内侧的主机之间也可以建立连接进行通信。有了这个方法，就可以让哪些NAT内侧的主机进行相互通信。此外，应用还可以与NAT路由器进行通信生成NAT表并通过一定的方法将NAT路由器上附属的全局IP地址传给应用。

   	如此一来，NAT外侧和内侧可以进行通信，这种现象叫做“NAT穿越”。这种发放和已有的IPv4环境的兼容性非常好，即使不迁移到IPv6也可以通信自如。

  ​	**导致IPv4的寿命有被延长了**

  ​	也有着自己的问题，那就是NAT的规范越来越复杂化，应用的实现很耗时。而且应用一旦运行在一个开发者未预想到的特殊网路环境中，会出现无法正常工作，遇到状况是难于诊断的问题。



### 13.5 NAT和代理服务器

路由器往往都具备NAT设备的功能，通过NAT设备进行中转，完成子网设备和其他子网设备的通信过程

代理服务器看起来和NAT设备有一点像。客户端向代理服务器发送请求，代理服务器将请求发给真正要请求的服务器，服务器返回结果后，代理服务器又把结果回传给客户端

**代理服务器和NAT的区别**

- 从**应用上**讲，**NAT设备是网络基础设备之一**。解决得是IP不足的问题，**代理服务器则是更切近具体应用**，比如通过代理服务器进行翻墙，迅游这样的加速器，也是使用代理服务器
- 从**底层上**讲，**NAT是工作在网络层**，直接对IP进行替换，**代理服务器往往工作在应用层**
- 从**使用范围上**讲，**NAT一般在局域网的出口部署**；**代理服务器可以在局域网做也可以在广域网做，也可以跨网**
- 从**部署位置上**看，**NAT一般集成在防火墙，路由器等硬件设备**；**代理服务器则是一个软件程序，需要部署在服务器上**

**代理服务器是一种应用广泛的技术**

- 翻墙：广域网中的代理
- 负载均衡：局域网中的代理

代理服务器又分为**正向代理和反向代理**

举例：

> 花王尿不湿是一个很经典的尿不湿品牌, 产自日本.我自己去日本买尿不湿比较不方便, 但是可以让我在日本工作的表姐去超市买了快递给我. 此时超市看到的买家是我表姐, 我的表姐就是 "正向代理";后来找我表姐买尿不湿的人太多了, 我表姐觉得天天去超市太麻烦, 干脆去超市买了一大批尿不湿屯在家里, 如果有人来找她代购, 就直接把屯在家里的货发出去, 而不必再去超市.此时我的表姐就是“反向代理”

- **正向代理是请求的转发**
- **反向代理往往作为一个缓存**



## 14. DHCP

### 14.1 DHCP实现了即插即用

如果**逐一为每一个主机设置一个IP地址会非常的繁琐**的事情。特别是用**移动设备**笔记本电脑，智能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置IP地址。

于是为了**实现自动设置IP地址、统一管理IP地址分配，就产生了DHCP（Dynamic Host Configuration Protocol）协议**。有了DHCP，计算机只需要连接到网络就可以进行TCP/IP通信。也就是说，DHCP让**即插即用**变得可能。而DHCP不仅可以**在IPv4中使用，在IPv6中也可以使用。**

**即插即用：指只要物理一连接上无需专门设置就可以直接使用这个物理设备**

对于**没有DHCP服务**的网络中，当用户接入到网络中的时候必须先**设置IP地址和子网掩码**。就需要询问管理员，对于管理员来说，对于**分配的IP地址必须要保证IP地址的唯一性**，不能重复，防止进行**网络通信的时候出现错误**。用户必须**手动设置**从管理哪里听来的消息。相反有了DHCP服务之后就**不需要手动**设置I**P地址，子网掩码，默认路由以及DNS服务器**这些信息了。

插图：DHCP

![](C:\Users\0\Pictures\Linux网络\网络层\DHCP.jpg)



### 14.2 DHCP的工作机制

使用之前必须要先架设一台**DHCP服务器**。然后将要进行**分配的IP地址设置到服务器**上。此外还要将相应的**子网掩码，DNS服务器的地址，路由控制信息**等设置到服务器上。

**该服务器一般都是该网段的路由器来充当**

在发送**DHCP发现包和请求包**时，DHCP即插即用的IP地址还不知道，所以DHCP的发现包的**目的地址是255.255.255.255也就是广播地址，而源地址就是0.0.0.0，表示未知。**

插图：DHCP的工作原理

![](C:\Users\0\Pictures\Linux网络\网络层\DHCP的工作原理.jpg)

DHCP在分配IP地址的时候有两种方法：

- **动态IP：**由DHCP服务器在待定的IP地址中选择出一个进行分配
- **静态IP：**针对MAC地址分配出一个固定的IP地址

**对于这两种方法可以并用**

使用DHCP服务器的时候为了防止DNCP服务器遇到故障，将导致无法自动分配IP地址，从而导致网段内所有的主机之间无法进行TCP/IP通信。人们通常会架设两台或者两台以上的DHCP服务器。由于多个DHCP服务器内部都记录着IP地址的分配情况的信息，因此可能会导致基础分配的IP地址相互冲突。

**解决方法：**

- **DHCP服务器（ping）**

  在分配IP地址前发送ICMP回送请求包，确定没有返回应答（其实也就是ping一下），测试该主机有没有IP地址

- **DHCP客户端（ARP）**

  针对从DHCP处得到的IP地址发送ARP请求包，确认没有返回应答。（确认有没有其他人没有使用同一个IP地址）

**在获得IP地址的时候做这些处理可能会消耗一些时间，但是可以安全的进行IP地址分配**



### 14.3 DHCP中继代理

家庭网络大多都只有一个以太网（无线LAN）的网段，与其连接的主机台数也不会太多。因此，主要有一台DHCP

服务器就可以应对IP地址分配的需求，大多数情况下都是由宽带路由器充当这个角色。

但是对于一个企业或者一个学校来说的话，一般会有多个以太网（无线LAN）网段。这种情况下要是对每个网段都分配DHCP服务器的话，将是一个庞大的工程，即使路由器可以担任DHCP的角色，但是如果有100个网段的话，就需要100个服务器设置他们可以进行分配IP地址的范围，并对这些范围的**IP地址进行后续的维护**。这将是一个**极其耗时和难于管理**的工作。

对于这种情况就需要DHCP中继代理来实现了。有了**中继代理之后对于不同网段的IP地址的分配也可以由一个DHCP服务器来进行管理和运维。**

这种方法是的**每一个网段架设一个DHCP服务器被取代，只需要在每个网段设置一个中继代理**即可。他可以**设置DHCP服务器的地址，从而可以在DHCP服务器上为每个网段注册IP地址的分配范围。**

**DHCP中级代理一般是路由器，不过也有在主机中安装一些软件实现的**

插图：DHCP中级代理

![](C:\Users\0\Pictures\Linux网络\网络层\DHCP中继代理.jpg)

DHCP客户端向DHCP中级代理发送DHCP请求包，在DHCP中级代理收到这个请求包之后再以单播的形式发送给DHCP服务器。服务器端收到该包之后，在向DHCP中继代理返回应答。并有DHCP中继代理将这个包转发给DHCP客户端。由此**DHCP服务器即使不再同一链路上也可以实现统一分配和统一管理IP地址。**

**DHCP请求包中包含发出主机的MAC地址**。DHCP中继代理就是使用MAC地址将DHCP服务器的应答返回给了DHCP客户端。（所以**DHCP中继代理和DHCP客户端必须在同一条链路上**）









