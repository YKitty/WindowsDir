# 写list出现的问题

---

## 1. 对于拷贝构造（现代写法）

> 自己没有实现const iterator就无法直接使用迭代器构造来初始化一个list，从而达到使用std::swap函数，来直接交换这两个头指针
>
> #### 可以直接使用std::swap的原因
>
> 由于系统自己实现的**swap是进行和浅拷贝一样的逻辑**，是使用**一个字节一个字节进行交换**的
>
> 对于指针来说，都是是个字节，所以就没有差别，可以直接使用std::swap进行交换
>
> 代码：
>
> ``` c++
> void swap(mylist<int>& ml)
> {
>     //对于系统自己实现的swap,只是浅拷贝，对于交换指针，已经够了
>     std::swap(_head, ml._head);
> }
> ```
>
> 



## 2. 对于operator=（现代写法）

> 有着**两种写法**：
>
> - 第一种：**不管赋值的对象是不是自己，直接在传参的时候直接进行拷贝构造，然后在用参数和当前对象进行swap交换即可。**
> - 第二种：需要**考虑赋值的对象是自己**。进来的时候进行一个判断
>   - 如果**是自己**的话，就**直接返回当前对象**
>   - **不是自己**的话，那就**采用拷贝构造拷贝出一个赋值对象，然后用该对象和赋值对象进行swap交换即可**
>
> 代码：
>
> ``` c++
> //现代写法
> //直接拷贝不管是不是自己给自己拷贝
> mylist<T>& operator= (mylist<T> ml)
> {
>     swap(ml);
> 
>     return *this;
> }
> 
> //拷贝的时候判断一下是不是自己给自己拷贝
> mylist<T>& operator= (mylist<T>& ml)
> {
>     if (this != &ml)
>     {
>         mylist<T> temp(ml);//拷贝构造
>         swap(temp);
>     }
> 
>     return *this;
> }
> ```
>
> 



## 3. 对于operator=调用拷贝构造的注意事项

> - **const对象可以调用const函数，不可以调用非const函数**
> - **非const对象既可以调用非const函数，也可以调用const函数**



## 4.实现insert函数和erase函数

> 函数原型：
>
> ``` c++
> void insert(iterator pos, const T& d);
> void erase(iterator pos);
> ```
>
> 对于实现insert函数的时候，是使用**iterator迭代器**进行**查找插入位置，来进行插入**的
>
> 对于传入进行进来的**迭代器也是一个对象**，对于该对象可以调用该类中的所有public成员函数或者成员变量
>
> 所以讲迭代器传入进来的时候，**想要找到下一个结点**，就需要使用**迭代器访问_node成员变量**，然后利用**该成员变量在找到下一个节点**
>
> ``` c++
> Node* posNode = pos._node;//这是传入迭代器所指向的该节点的指针
> Node* back = posNode->_next;//这是迭代器所指向结点的下一个结点的指针
> ```
>
>  
>
> **【总结】**
>
> - **对于传入一个迭代器的时候，使用该迭代器来访问其结点指针**
> - **传入进来的迭代器是一个对象，其结点指针是这个迭代器的成员变量**



## 5. 代码的复用性

> - 对于**头插尾插，头删尾删**的功能
> - 可以**使用插入删除**来实现这些功能，从而提高了代码的复用性
> - 只需要将**插入删除写好调试好**就行了



## 6. 实现基本迭代器begin()和end()

> 实现迭代器的时候要考虑的问题：
>
> - 由于**迭代器的本质是一个指针**，所以该迭代器也就要是**一个list对象的指针**
> - **迭代器**要**具有**的**功能**，迭代器要实现**++，*，+， != ， ==**等操作
> - 那么对于一个**未经封装的list指针**，使用系统提供的这些操作，是不可能实现这些的，所以需要自己将**指针以及这些操作封装起来**
>
> 所以对于迭代器来说：**自己封装一个类，然后将这些操作，都进行重载，这样就可以实现迭代器了**



## 7. 必须要记住

> 对于一个类来说，其里面必须要有六大函数
>
> 首选第一个成员函数就是**构造函数**
>
> 所以**只要自己写了一个类的话，不希望系统自己生成一个构造函数，就必须自己写一个构造函数，从而实现各种自己想要实现的功能**
>
>  
>
> **【c++中的struct和c中的struct的区别】**
>
> - **c中的struct**只可以在其中进行**变量的定义**，但是对于**c++既可以在struct中进行变量定义，也可以进行方法的定义**
> - **c**中使用**struct创建**出来的是**一个变量**，**c++中创建**出来的是**一个对象**。
> - 对于**c和c++的共同之处**就是，对于struct里面的不管是c和c++中的变量或者c++中的函数，**访问权限都是public的**
>
> 



## 8. 迭代器的前置++和后置++，以及如何区别是哪一种

> **【如何区别前置++和后置++呢】**
>
> - 首先写出其两种形式
>   - **iterator operator++ ();**
>   - **iterator operator++ (int);**
> - **那么带int的后置++，不带int的是前置++**
>
> **【记忆技巧】**
>
> - 对于**int**我们就将其**理解为一个整数**，不管带不带int我们都将**++移到括号的后面**。
> - 如果是**带int**的话，那么就有**一个数在++的前**面这样的话，就是**int++**，这种形式了，那肯定就是**后置++**了，**反之就是前置++**。
>
> 



## 9. 正向迭代器

> 对于迭代器必须要写的两大成员函数就是构造函数和拷贝构造函数，其实也只可以**只写一个构造函数**
>
> 也可以不写**拷贝构造函数**，因为对于**迭代器**其本质是一个**指针**，所以使用拷贝构造函数，也就是拷贝一个指针，如果使用系统自己生成的一个函数，是按照**一个字节一个字节拷贝成员变量**的。对于**成员变量只有指针也是可以实现的。**
>
> 对于迭代器一般实现的操作都是前置++和后置++， 以及*（解引用），前置--和后置--，!= 和 == 
>
> **实现解引用**
>
> - 实现解引用的话，返回值可以直接是一个引用，因为对其进行解引用的话，出了这个函数，这个地址空间的值还没有发生改变。所以可以返回解引用。
>
> **实现->**
>
> - 对于**实现->**的话，也就是对于一个对象可以使用**->**，那么就可以求出该对象的地址就可以了。
> - 比如：list<Date>的话，list里面放的是一个**日期类**。那么对于该list的迭代器，如果使用该**迭代器改变数据**的话，那么就要**改变成员变量中的其中一个**。那么就可以**使用->**了。
>
> 为什么要**实现解引用和->**
>
> - 由于对于一个迭代器要可以访问数据就必须解引用，对于**解引用要返回的是一个引用**，对于**->要返回的是一个指针。**
> - 因为对于迭代器有着非const迭代器还有这const迭代器
> - 但是对于**const迭代器和非const迭代器**的**区别就在于可以修改成员变量吗**
> - 对于可以修改成员变量就在于解引用和->，所以就要将这两个实现好。
>
> **实现const迭代器和非const迭代器**
>
> - 实现const迭代器和非const迭代器也就是**对于*（解引用）和->的返回值类型不同**，**const迭代器**返回的就是**const类型的成员变量**，对于**非const迭代器**返回的就是**非const类型的成员变量**



## 10. 反向迭代器

> **【如何实现反向迭代器】**
>
> - **反向迭代器的成员变量就是正向迭代器**
>   - **所以对于反向迭代器可以就是正向迭代器的适配器，只要给一个正向迭代器就可以实现该容器的反向迭代器**
>
> - **对于实现反向迭代器可以利用正向迭代器进行实现就可以了。**
> - **因为反向迭代器也是对于一个指针的封装只是对于，++，--等处理不一样了，进行了改变而已。**
> - **反向迭代器的++，也就是正向迭代器的--**
> - **反向迭代器的--，也就是正向迭代器的++**
> - **对于实现反向迭代器的*（解引用）和->和正向迭代器都是一样的。**



## 11. 正向迭代器和反向迭代器的实现

> ``` c++
> //自己进行重命名
> 
> typedef ListIterator<T, T&, T*> iterator;
> typedef ListIterator<T, const T&, const T*> const_iterator;
> typedef ReverseIterator<T, T&, T*, iterator> reverse_iterator;
> typedef ReverseIterator<T, const T&, const T*, const_iterator> const_reverse_iterator;
> ```
>
> 
>
> ``` c++
> //正向迭代器的实现
> 
> //正向迭代器
>   //迭代器本质上还是一个指针，只不过对于该指针的操作不一样了
>   template <class T, class Ref, class Ptr>
>   struct ListIterator 
>   {
>     typedef ListNode<T> Node;
>     typedef ListIterator<T, Ref, Ptr> Self;
>     ListIterator (Node* node = nullptr)
>       : _node(node)
>     {
>     }
> 
>     ListIterator (const Self& d)
>       : _node(d._node)
>     {
>     }
> 
>     Ref operator* ()
>     {
>       return _node->_data;
>     }
> 
>     Ptr operator-> ()
>     {
>       return &(operator*());
>     }
> 
>     //后置++
>     //拷贝一份当前迭代器，然后返回拷贝好的迭代器
>     Self operator++ (int)
>     {
>       Self temp(*this);
>       _node = _node->_next;
> 
>       return temp;
>     }
> 
>     //前置++
>     Self& operator++ ()
>     {
>       _node = _node->_next;
> 
>       return *this;
>     }
>     
>     //后置--
>     //拷贝一份当前迭代器，然后返回拷贝好的迭代器
>     Self operator-- (int)
>     {
>       Self temp(*this);
>       _node = _node->_prev;
> 
>       return temp;
>     }
> 
>     //前置--
>     Self& operator-- ()
>     {
>       _node = _node->_prev;
> 
>       return *this;
>     }
> 
>     bool operator!= (const Self& it)
>     {
>       //两个不相等返回true，相等返回false
>       return _node != it._node;
>     }
> 
> 
>     Node* _node;
>   };
> ```
>
>  
>
> ``` c++
> //反向迭代器的实现
> 
> //反向迭代器
>   //
>   template <class T, class Ref, class Ptr, class iterator>
>   struct ReverseIterator 
>   {
>     typedef ListNode<T> Node;
>     typedef ReverseIterator<T, Ref, Ptr, iterator> Self;
>     ReverseIterator (const iterator& it)
>       : _it(it)
>     {
>     }
> 
>     ReverseIterator (const Self& it)
>       : _it(it._it)
>     {
>     }
> 
>     Ref operator* ()
>     {
>       return _it._node->_data;
>     }
> 
>     Ptr operator-> ()
>     {
>       return &(operator*());
>     }
> 
>     //后置++
>     //拷贝一份当前迭代器，然后返回拷贝好的迭代器
>     Self operator++ (int)
>     {
>       //使用默认的拷贝构造，按字节拷贝
>       Self temp(*this);
>       _it--;
> 
>       return temp;
>     }
> 
>     //前置++
>     Self& operator++ ()
>     {
>       _it--;
> 
>       return *this;
>     }
> 
>     //后置--
>     //拷贝一份当前迭代器，然后返回拷贝好的迭代器
>     Self operator-- (int)
>     {
>       Self temp(*this);
>       _it++;
> 
>       return temp;
>     }
> 
>     //前置--
>     Self& operator-- ()
>     {
>       _it++;
> 
>       return *this;
>     }
> 
>     bool operator!= (const Self& it)
>     {
>       //两个不相等返回true，相等返回false
>       return _it != it._it;
>     }
> 
> 
>     iterator _it;
>   };
> ```
>
> - **可以看出反向迭代器的成员变量就是正向迭代器，这就说明只要给出一个正向迭代器就可以实现反向迭代器，也就是适配器**



## 12. 对于const对象可以调用的方法或者函数

> 对于这个list容器创建一个const对象，这个const对象对于成员函数中的const函数不能调用，但是将该函数放到析构函数中就可以调用了，这是为什么？
>
> - 因为对于析构函数的调用，是在**对象被销毁的时候**由操作系统调用析构函数的。所以就不存在const类型的对象不了非const类型的函数。
> - **析构函数是由操作系统调用的**



