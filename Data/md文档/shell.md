# shell

## 1. 符号

shell是不能挂掉的，如果他挂掉了，就会导致外壳程序挂掉了，从而也执行不了其他的命令了。所以是使用bash来完成的

shell执行任务：创建子进程->子进程去执行命令->父进程在等待->子进程返回结果

**windows中的鼠标是shell中命令的替代者。**

shell相当于就是bash的父类

shell只需要一个能编写代码的文本编译器和一个能解释执行的脚本解释器

**shell外壳程序。**

**输入一条命令进行回车这是交互式**

**批处理式：将多条命令放在一个文件中一起执行**

对于交互式和批处理式的对比：

对于每天工作之前都要执行100条命令。

对于交互式是要自己每天敲100条命令。而对于批处理式则只需要第一次输入100条命令对于以后就不需要每天敲这么多的命令了，只需要执行就可以了。起到了一劳永逸的效果





**【重点】提高我们的工作效率**

**把所有命令写到文件中就是shell脚本**

Linux脚本的解释器种类众多：

- Bash
- csh
- ksh
- sh

bash是Linux默认的一个shell脚本

shell特点：

- 解释非编译型
- 弱类型
- 执行模式：交互式/批处理式

弱类型：没有类型，不需要类型

**shell脚本把所有变量中的内容全部当成字符串来看**

shell是一个二进制解释器。file /bin/bash

python也是一个二进制解释器. file  /usr/bin/python



1. 对于执行一个程序的时候，操作系统只认识二进制文件。但是对于执行test.sh文件。fork出一个子进程，然后exec执行test.sh，但是test.sh不是二进制文件，所以不能直接执行test.sh文件。但是对于文件中第一行有这解释器,所以exec是直接执行这个解释器，然后将test.sh文件中的内容作为这个解释器的参数来进行执行。对于这种情况该文本文件要有可执行的权限
2. 也可以使用bash tetst.sh来执行该文件。bash当成一条命令，test.sh当做一个参数传递给解释器。这是使用exec直接执行解释器，然后对于后面的脚本文件中的内容按行读取逐行解释

shell脚本是非编译性的解释性的弱类型语言，它的执行并不是自己亲自执行，而是由现将其解释器跑起来，然后再有解释器读取脚本文件中的内容，按行读取，逐行解释



父进程也是一个bash，是交互式bash

子进程是一个bash，子进程在执行shell脚本的时候要遵守shell的执行原理

原则上shell脚本当中的内容按行读取，原则上每一行都可以被当做一条命令。 

子bash在进行执行执行之时是如何执行的。

fork创建子进程，子进程读取脚本文件当中的第一行，exec到解释器

然后读取一行执行一行

每个进程都有自己的工作目录。

对于

``` shell
#!/bin/bash

pwd
cd ..
pwd
```

发现执行完了之后，但是对于当前目录没有改变。但是再执行的时候还是输出了上一结构的目录

对于这个执行，因为没有影响到交互式bash（即父进程），所以对于目录没有发生该变。影响的只是子进程的工作目录。没有影响到父进程的工作目录

在交互式bash当中执行的没有产生子进程去执行的叫做内建命令。这种命令执行之后，直接影响到了父进程的工作目录

在执行shell脚本文件时，是创建出来的子进程来执行的，所以不会影响到交互式的bash

**export和cd，还有.命令和source都是内建命令**

``` shell
#!/bin/bash 

echo "hello world"
```

给解释器后面不要加东西，否则无法使用可执行形式进行执行

对于#！也叫作shebang也就是解释器

并不是文本在跑而是解释器在跑，解释器只是对于文本进行解释

对于其他的需要创建子进程来执行。

cd命令在执行的时候不需要创建子进程，cd叫做内置命令。直接由shell执行。（一般不会出错，所以可以由shell直接执行不害怕会出错）

echo也是内置命令



**shell执行原理：**

先检测该命令是不是内置命令->是，直接执行->不是创建子进程执行

查找命令,在PATH环境变量中查找命令，直接创建子进程，父进程等待

符号：

``` Shell
. ./test.sh 
source ./test.sh 
```

不许创建子进程必须使用父bash亲自去执行



## shell 变量

shell是弱类型语言，不需要定义需要的时候直接去用

命名做到见名知意

对于shell对于变量进行赋值的时候不能在**`=`**两边**放置空格**

shell脚本里面都是命令所以对于=两边不能带空格

字符串拼接，直接写在一起就可以了。如果害怕产生新的变量只需要加上{}

一个从来没有出现的变量默认是空串，所以将一个变量设置为空串也就是删除一个变量

或者使用unset删除一个变量，unset不能删除只读变量，因为这是对变量进行了修改，所以不能进行删除



## 变量类型

本地变量

环境变量

shell变量



对于直接在命令行（父shell）定义一个变量，在交互式父shell是可以直接访问的。但是在子脚本中访问，却访问不到



平时定义就是本地变量，对于使用export可以导成环境变量

shell变量是由shell程序设置的特殊变量，shell变量中有一部分环境变量，有一部分是局部变量



将x导成环境变量，对于子bash是可以看到父进程中的环境变量。并且访问到父进程的环境变量



export x=100 #直接变成环境变量

x=100

export x #分为两步导成环境变量

unset x #将其不变成环境变量

set命令可以显示当前shell进程中定义的所有变量（包括本地变量和环境变量）和函数

使用printenv可以显示当前shell进程的环境变量



环境变量在创建子进程会被继承下去

对exec不会改变环境变量





文件名代换

- 通配符*：匹配0个或任意多个任意字符
- ？：匹配一个任意字符
- [若干字符]：匹配方括号中任意一个字符的一次出现

file [2345];

ls file[2345]显示file2，file3，file4，file5

file [ ^ 1-9 ]显示file0，也就是1-9的非



命令代换



ret=$(data +%Y:%m:%d)``和$()都可以命令代换，只可以对命令字符操作

``       反引号

由反引号括起来的也是一条命令，Shell先执行该命令，然后将输出结果立刻代换到当前命令行中

命令代换也可以使用$()来实现



算术代换：

用于算术计算，$(())中的Shell变量取值将转化成整数，例如：

``` Shell
VAR=13
echo $((VAR+3))
```

$(())中只能用+-*/和()运算符，并且只能做整数运算

进行计算

```shell
a=1
b=2
（（c = a + b））#c语言风格随意加空格
c=$((a + b)) #对于（）外面都是shell所以要使用$提取中其中的内容
echo $c
```

调查:eval命令



转义字符：

和C语言一样，\在Shell中被用作转义字符，取出其后字符表面的意思

创建出文件名为**$ $**，使用 

``` Shell
\$\ \$#来创建，
rm \$\ \$#来删除
```

  

创建出文件名为-file。这里的-不是特殊符号

使用touch -- -file或者touch ./-file创建，删除也要用这种来进行删除就可以了





单引号和双引号

**单引号和双引号都是用来表示字符串**

单引号和双引号的区别：

单引号不会对内部的所有内容做特殊解释，保持字面值

即使引号内的\和回车也不例外，但是字符串不能出现单引号。如果引号没有匹配就会输入回车，Shell会给出续行提示符，要求用户把引号配上对

双引号会对内部的内容做特殊的解释，比如转义字符和变量以及命令代换做出响应

例：

``` Shell
#!/bin/bash 

val=100

echo "################1#############"
echo "hello world : \` : \" : \\ : $val : $(date +%Y)"
echo "################2#############"
echo 'hello world : \` : \" : \\ : $val : $(date +%Y)'

#输出
################1#############
hello world : ` : " : \ : 100 : 2019
################2#############
hello world : \` : \" : \\ : $val : $(date +%Y)
```



## 2. 语法

- 条件测试
- test或[可以测试一个条件是否成立。结果为真0，结果为假是1

测试整形

为了防止和其他程序混淆，所以退出码不一样

[是一个命令所以必须要用空格隔开

``` Shell
#-eq:equal (等于)
#-ne:not equal (不等于)
#-lt:less than (小于)
#-gt:great than (大于)
#-le:less and equal (小于等于)
#-ge:grear and equal (大于等于)
[ $myint -eq 100 ]
```



测试字符串：

``` Shell
#!/bin/bash

read mystr
# == != =(相等) 
#-z 是否为空串
#-n 是否为非空串
[ $mystr == 'helloworld' ]
echo?

#对于字符比较，一般给左右两端都加上""和X
#加上X是为了防止出现空串
#加上""表示内部是字符串，对于""以及''都是定界符
```



测试文件

``` Shell
[ -d ] 目录
[ -f ] 普通文件
[ -z ] 长度为零真
[ -n ] 长度非零真
[ -b ] 块设备：
[ -c ] 字符设备
```



多条件的测试

``` Shell

```



Shell脚本认为if语句中不能出现空的代码块

并且可以支持嵌套。Shell脚本当中内部不准出现空的代码块，函数以及

**：**什么都不做还认为条件为真



双中括号支持支持统配符以及正则表达式





对于逻辑与，或，非

-a -o ！对于这三个是连接字符串的

&& || ！ 是连接命令的



let i++或者((i++  ))

循环

for



while



for in {a..z}

for in {1..2}{a..c} #穷举



$$：解释该进程的pid，子bash 



函数返回值有两种：

echo或者return

echo只有一种输出结果。返回类型丰富字符串，任意类型

return返回的是命令的退出码，所以必须是整数，不能返回其他的类型



fork炸弹

``` Shell
.() { . | . & }; .
```







eval就是对其参数，将其内容取出来，再次进行一次命令行处理

例：

```` Shell
echo "Last Parament: \$$#"
eval echo "Last Parament: \$$#"

#./test.sh 1 2 3 4
Last Parament: $5
Last Parament: 4
#取出最后一个命令行参数

a=100
echo '${'a'}' #S{a}
eval echo '${'a'}' #100
````



``` Shell

```































































































## 3. 工具



## 4. 正则表达式





**【注意】没有指针，结构体，数组，数据类型**



40:00





