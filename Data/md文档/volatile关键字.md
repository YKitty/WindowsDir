# volatile关键字

---

- volatile的含义是“易变的”，含义是说这变量有可能会被意想不到的改变，这样的话，编译器就不会去假设这个变量的值，也就是不会为了优化到寄存器中读取这个变量的值，会每次都到内存中读取
- 是一个类型修饰符。
- 作用：
  - 作为指令的关键字，确保本条指令不会因为编译器的优化，直接到内存中读取变量的值



## 作用：

- 简单来说就是：防止编译器对于代码进行优化

- 比如：

  - ``` c++
    variable = 1;
    variable = 2;
    variable = 3;
    variable = 4;
    
    //对于外部硬件来说，这四条语句分别表示不同的操作，会产生四种不同的动作，但是编译器会对上述四条语句进行优化，认为只有variable = 4（即忽略前三条语句，只产生一条机器代码）。如果键入volatile的话，编译器会逐一的进行编译并产生相应的代码。
    ```



## 例子

- 编译器每次用到这个变量的时候必须小心的从重新读取这个变量的值，而不是使用保存在寄存器中的备份。

- 以下是几个例子：

  - 并行设备的硬件寄存器
  - 一个中断服务子程序中会访问到非自动变量
  - 多线程应用中被几个任务共享的变量

- 【面试题】：

  1. 一个参数既可以是const也可以是volatile吗？解释一下为什么。

  - 可以。对于一个变量，它是volatile因为他可能被意想不到的改变，它是const因为程序不应该试图去修改它

  2. 一个指针可以是volatile吗？解释一下为什么？

  - 可以。因为指针也是变量与参数一样

  3. 下面的函数可以实现计算某个整数的平方吗？如果不能，试回答存在什么问题？

  ``` c++
  int square(volatile int* ptr)
  {
      return ((*ptr) * (*ptr));
  }
  ```

  - 这段代码是用来返回*ptr所指向的值的平方。但是，由于 *ptr指向的是一个volatile型的参数，编译器将会产生类似下面的代码。

  ``` c++
  int square(volatile int* ptr)
  {
      int a, b;
      a = *ptr;
      b = *ptr;
      return a * b;
  }
  ```

  - 由于ptr的值可能在两次取值语句之间发生改变，因此a和b可能是不同的。
  - 正确的代码如下：

  ``` c++
  long square(volatile int* ptr)
  {
      int a;
      a = *ptr;
      return a * a;
  }
  ```

  ## 关键在于编译器的优化

  > - 在本次线程内，当读取一个变量的时候，为提高存取速度，编译器优化是有时会先把变量读取到一个寄存器中去，以后再取变量值时，就直接从寄存器中取值。
  > - 当变量在本线程里改变时，会同时把变量的新值copy到寄存器中，以便保持一致
  > - 当变量在因别的线程等而改变了值，该寄存器的值，不会相应改变，从而造成应用程序读取的值和实际变量值不一致
  > - 当该寄存器在因别的线程等改变了值，原变量的值不会改变，从而导致应用程序读取的值和实际的变量值不一致
  >   - 举个例子：
  >   - 发薪资是，会计每次都把员工叫来登记他们的银行卡号：一次会计为了省事，没有及时登记，用了以前登记的银行卡号；刚好一个员工的银行卡丢了，已挂失该银行卡号，从而导致该员工领不到工资。
  >   - 员工----原始变量地址
  >   - 银行卡号----原始变量在寄存器的备份



## 代码

``` c++
#include <iostream>
#include <signal.h>
#include <unistd.h>
using namespace std;

volatile int flag = 0;

void handler(int signo)
{
  flag = 1;
  cout << "change flag to 1" <<  endl;
}


int main()
{
  //捕捉SIGINT信号，然后执行自定义函数
  signal(SIGINT, handler);
  while (!flag)
  {
  }

  cout << "proc done..." << endl;
  return 0;
}
```





































